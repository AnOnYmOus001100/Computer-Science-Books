<HTML>

<HEAD>

<TITLE>Tricks of the Internet Gurus tig11.htm</TITLE>

<LINK REL="ToC" HREF="httoc.htm">

<LINK REL="Index" HREF="htindex.htm">

<LINK REL="Next" HREF="tig12.htm">

<LINK REL="Previous" HREF="tigp3.htm"></HEAD>

<BODY TEXT="#000000" LINK="#0000FF" VLINK="#800080" bgcolor=white>

<P><A HREF="tigp3.htm"><IMG SRC="bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Previous Page"></A>

<A HREF="httoc.htm"><IMG SRC="blutoc.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="TOC"></A>

<A HREF="htindex.htm"><IMG SRC="bluindex.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Index"></A>

<A HREF="tig12.htm"><IMG SRC="blunext.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Next Page"></A>

<A HREF="httoc.htm"><IMG SRC="bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Home"></A>

</P><UL>

<LI>

<A HREF="#I1">11</A></LI>

<UL>

<LI>

<A HREF="#I3">Online Entertainment for the Internet Guru</A></LI>

<UL>

<LI>

<A HREF="#I4">How to Program Muds</A></LI>

<LI>

<A HREF="#I5">Chapter Overview</A></LI>

<LI>

<A HREF="#I6">Notation</A></LI>

<LI>

<A HREF="#I7">Overview of Common Mud Commands</A></LI>

<UL>

<LI>

<A HREF="#I8">Connecting to the Mud</A></LI></UL>

<LI>

<A HREF="#I9">You can connect to the mud using telnet:</A></LI>

<UL>

<LI>

<A HREF="#I10">Connecting to a Character</A></LI>

<LI>

<A HREF="#I11">Obtaining Help</A></LI></UL>

<LI>

<A HREF="#I12">This may lead to more specific help topics. You can type</A></LI>

<UL>

<LI>

<A HREF="#I13">Talking</A></LI>

<LI>

<A HREF="#I14">Acting out Actions</A></LI>

<LI>

<A HREF="#I15">Looking at Objects</A></LI>

<LI>

<A HREF="#I16">Moving Around</A></LI>

<LI>

<A HREF="#I17">Whispering to Other Players</A></LI>

<LI>

<A HREF="#I18">Paging other Players</A></LI>

<LI>

<A HREF="#I19">Picking up Objects</A></LI>

<LI>

<A HREF="#I20">Dropping Objects</A></LI>

<LI>

<A HREF="#I21">Listing What You Are Carrying</A></LI>

<LI>

<A HREF="#I22">Finding out Who Else Is Playing the Mud</A></LI>

<LI>

<A HREF="#I23">Returning to Your Home</A></LI>

<LI>

<A HREF="#I24">Quitting the Mud</A></LI></UL>

<LI>

<A HREF="#I25">How to Program MUCKs, MUSHes, and MUSEs: A Tutorial</A></LI>

<UL>

<LI>

<A HREF="#I26">Objects</A></LI>

<LI>

<A HREF="#I27">DBREF</A></LI>

<LI>

<A HREF="#I28">Money</A></LI>

<LI>

<A HREF="#I29">Wizards and Officials</A></LI>

<LI>

<A HREF="#I30">At-Commands</A></LI>

<LI>

<A HREF="#I31">Flags</A></LI>

<LI>

<A HREF="#I32">Messages</A></LI>

<LI>

<A HREF="#I33">Creating and Naming Objects</A></LI>

<LI>

<A HREF="#I34">Attributes</A></LI>

<LI>

<A HREF="#I35">Action Lists</A></LI>

<LI>

<A HREF="#I36">Examining</A></LI>

<LI>

<A HREF="#I37">More Movement Commands</A></LI>

<LI>

<A HREF="#I38">Killing</A></LI>

<LI>

<A HREF="#I39">Giving and Receiving Objects</A></LI>

<LI>

<A HREF="#I40">Finding and Searching for Objects</A></LI>

<LI>

<A HREF="#I41">Rooms and Exits</A></LI>

<LI>

<A HREF="#I42">Rooms as Homes</A></LI>

<LI>

<A HREF="#I43">Examining Exits</A></LI>

<LI>

<A HREF="#I44">Exit Attributes</A></LI>

<LI>

<A HREF="#I45">Special Exits</A></LI>

<LI>

<A HREF="#I46">Other Flags on Rooms and Exits</A></LI>

<LI>

<A HREF="#I47">Unlinking Exits</A></LI>

<LI>

<A HREF="#I48">Containers</A></LI>

<LI>

<A HREF="#I49">Enter and Leave Attributes</A></LI>

<LI>

<A HREF="#I50">Pronoun Substitutions</A></LI>

<LI>

<A HREF="#I51">Try It Out!</A></LI></UL>

<LI>

<A HREF="#I52">Programming a MUCK</A></LI>

<UL>

<LI>

<A HREF="#I53">Popular MUCKs</A></LI></UL>

<LI>

<A HREF="#I54">Things Specific to MUCKs</A></LI>

<UL>

<LI>

<A HREF="#I55">MUF Programming</A></LI>

<LI>

<A HREF="#I56">Using the MUF Editor and Compiler</A></LI>

<LI>

<A HREF="#I57">MUF Basics</A></LI>

<LI>

<A HREF="#I58">Basic MUF Functions</A></LI>

<LI>

<A HREF="#I59">Variables</A></LI>

<LI>

<A HREF="#I60">Messages</A></LI>

<LI>

<A HREF="#I61">Conditional Statements</A></LI>

<LI>

<A HREF="#I62">An Example MUF Program</A></LI></UL>

<LI>

<A HREF="#I63">Programming a MUSH</A></LI>

<UL>

<LI>

<A HREF="#I64">Popular MUSHes</A></LI></UL>

<LI>

<A HREF="#I65">Things Specific to MUSHes</A></LI>

<UL>

<LI>

<A HREF="#I66">Possessive Pose</A></LI>

<LI>

<A HREF="#I67">Puppets</A></LI>

<LI>

<A HREF="#I68">Listening and Responding to Messages</A></LI>

<LI>

<A HREF="#I69">Percent Substitutions</A></LI>

<LI>

<A HREF="#I70">Registers</A></LI>

<LI>

<A HREF="#I71">Triggers</A></LI>

<LI>

<A HREF="#I72">Numbered Variables</A></LI>

<LI>

<A HREF="#I73">Braces</A></LI>

<LI>

<A HREF="#I74">Using an Object</A></LI>

<LI>

<A HREF="#I75">Functions</A></LI>

<LI>

<A HREF="#I76">The v() Function</A></LI>

<LI>

<A HREF="#I77">The s() Function</A></LI>

<LI>

<A HREF="#I78">The get() Function</A></LI>

<LI>

<A HREF="#I79">The rand() Function</A></LI>

<LI>

<A HREF="#I80">The Switch Command</A></LI>

<LI>

<A HREF="#I81">User-Defined Commands</A></LI>

<LI>

<A HREF="#I82">User-Defined Attributes</A></LI>

<LI>

<A HREF="#I83">The Queue</A></LI>

<LI>

<A HREF="#I84">The Wait Command</A></LI>

<LI>

<A HREF="#I85">The Halt Command</A></LI>

<LI>

<A HREF="#I86">Semaphores</A></LI>

<LI>

<A HREF="#I87">Putting It All Together: Exploding Jawbreaker Example</A></LI></UL>

<LI>

<A HREF="#I88">Programming a MUSE</A></LI>

<UL>

<LI>

<A HREF="#I89">Popular MUSEs</A></LI>

<LI>

<A HREF="#I90">MuseNet Worlds</A></LI></UL>

<LI>

<A HREF="#I91">Things Specific to MUSEs</A></LI>

<UL>

<LI>

<A HREF="#I92">Commands</A></LI>

<LI>

<A HREF="#I93">Classes</A></LI>

<LI>

<A HREF="#I94">Zones</A></LI>

<LI>

<A HREF="#I95">Interactive Narration: &quot;Monster Island&quot; Example</A></LI></UL>

<LI>

<A HREF="#I96">After a few seconds, we see...</A></LI>

<LI>

<A HREF="#I97">MUCK, MUSH and MUSE Reference</A></LI>

<UL>

<LI>

<A HREF="#I98">Concept Reference</A></LI>

<LI>

<A HREF="#I99">Control</A></LI>

<LI>

<A HREF="#I100">Costs</A></LI>

<LI>

<A HREF="#I101">Credits</A></LI>

<LI>

<A HREF="#I102">Drop-To</A></LI>

<LI>

<A HREF="#I103">Enactor</A></LI>

<LI>

<A HREF="#I104">$ and ! Events</A></LI>

<LI>

<A HREF="#I105">Exits</A></LI>

<LI>

<A HREF="#I106">Failure</A></LI>

<LI>

<A HREF="#I107">Home</A></LI>

<LI>

<A HREF="#I108">Linking</A></LI>

<LI>

<A HREF="#I109">me</A></LI>

<LI>

<A HREF="#I110">Names</A></LI>

<LI>

<A HREF="#I111">NULL Exits: Bogus Commands</A></LI>

<LI>

<A HREF="#I112">Numbers</A></LI>

<LI>

<A HREF="#I113">Objects</A></LI>

<LI>

<A HREF="#I114">Pronouns</A></LI>

<LI>

<A HREF="#I115">Stack</A></LI>

<LI>

<A HREF="#I116">Substitutions</A></LI>

<LI>

<A HREF="#I117">Success</A></LI>

<LI>

<A HREF="#I118">V-Registers</A></LI>

<LI>

<A HREF="#I119">Verb Commands</A></LI>

<LI>

<A HREF="#I120">Tips For Programmers</A></LI></UL>

<LI>

<A HREF="#I121">At-Commands Reference</A></LI>

<UL>

<LI>

<A HREF="#I122">At-Commands</A></LI></UL>

<LI>

<A HREF="#I123">Sets the number of columns that WHO prints. The default is 80.</A></LI>

<UL>

<LI>

<A HREF="#I124">Flag Reference</A></LI>

<LI>

<A HREF="#I125">Flags</A></LI></UL>

<LI>

<A HREF="#I126">Attribute Options Reference</A></LI>

<UL>

<LI>

<A HREF="#I127">Attribute Options</A></LI>

<LI>

<A HREF="#I128">MUF Function Reference</A></LI>

<LI>

<A HREF="#I129">Notation</A></LI>

<LI>

<A HREF="#I130">Parameter Types</A></LI></UL>

<LI>

<A HREF="#I131">MUF Functions</A></LI>

<UL>

<LI>

<A HREF="#I132">Arithmetic Functions</A></LI>

<LI>

<A HREF="#I133">Comparison Functions</A></LI></UL>

<LI>

<A HREF="#I134">MUSH and MUSE Function Reference</A></LI>

<UL>

<LI>

<A HREF="#I135">Functions</A></LI></UL>

<LI>

<A HREF="#I136">Returns the logarithm base 10 of the number.</A></LI>

<UL>

<LI>

<A HREF="#I137">Lock Reference</A></LI>

<LI>

<A HREF="#I138">Locks</A></LI>

<LI>

<A HREF="#I139">Object Design Worksheet</A></LI></UL>

<LI>

<A HREF="#I140">How To Program a MOO</A></LI>

<UL>

<LI>

<A HREF="#I141">Popular MOOs</A></LI>

<LI>

<A HREF="#I142">Basic Concepts</A></LI>

<UL>

<LI>

<A HREF="#I143">Basic Values</A></LI>

<LI>

<A HREF="#I144">Object Numbers</A></LI>

<LI>

<A HREF="#I145">Inheritance</A></LI>

<LI>

<A HREF="#I146">Verbs</A></LI>

<LI>

<A HREF="#I147">Properties</A></LI>

<LI>

<A HREF="#I148">Messages</A></LI>

<LI>

<A HREF="#I149">Inspecting Objects</A></LI></UL>

<LI>

<A HREF="#I150">Basic Commands</A></LI>

<LI>

<A HREF="#I151">At-Command Equivalencies</A></LI>

<LI>

<A HREF="#I152">MOO Programming</A></LI>

<UL>

<LI>

<A HREF="#I153">Expressions</A></LI>

<LI>

<A HREF="#I154">Statements</A></LI>

<LI>

<A HREF="#I155">Entering Verbs</A></LI></UL></UL>

<LI>

<A HREF="#I156">MOO Reference Manual</A></LI>

<UL>

<LI>

<A HREF="#I157">At-Command Reference</A></LI>

<LI>

<A HREF="#I158">Message Reference</A></LI>

<UL>

<LI>

<A HREF="#I159">Messages</A></LI></UL>

<LI>

<A HREF="#I160">Error Reference</A></LI>

<LI>

<A HREF="#I161">Built-In Function Reference</A></LI></UL>

<LI>

<A HREF="#I162">Summary</A></LI></UL></UL></UL>



<H1><A ID="I1" NAME="I1">

<BR>

<FONT SIZE=5><A ID="I2" NAME="I2"></A><B>11</B>

<BR></FONT></A></H1>

<H2><A ID="I3" NAME="I3">

<FONT SIZE=5><B>Online Entertainment for the Internet Guru</B>

<BR></FONT></A></H2>

<P>

<BR><B>--by Joseph R. Poirier and <A HREF=" TODFOLEY.gif">Tod Foley</A></B>

<BR></P>

<H3><A ID="I4" NAME="I4">

<FONT SIZE=4><B>How to Program Muds</B>

<BR></FONT></A></H3>

<P>Several years ago I joined the Information Superhighway and took the on ramp marked MUD, or Multi-User Domain.... What makes these games so enticing is that they are a step up from chat and e-mail. Not only is it possible to assume whatever personality 
you want, but you can act any way you want. You can kill without ever seeing blood, roar threats or cross swords without ever breaking into a sweat.... With MUDs and other on-line multiplayer games, you can live vicariously in a new universe and even 
attain godhood, thereby achieving omnipotence.

<BR></P>

<P>&#151;Kristina Harris, &quot;Godhood: Not All Fun and Games,&quot; &quot;My Turn,&quot; <I>Newsweek</I>, July 18, 1994, p. 12.

<BR></P>

<P>One of the advantages of access to the Internet is the increased ability for people from all over the world to meet, and one of the major meeting places is <I>interactive multi-user virtual </I><I>realities</I>. Also known as <I>multi-user dungeons</I>, 
or <I>MUDs</I>, these environments have expanded out of the game-playing niche into educational uses, corporate uses, and research. Some people call them multi-user domains in an attempt to de-emphasize the Dungeons and Dragons&#153; role-playing 
influences and highlight the multi-user side. Nowadays, the acronym MUD has been generalized to lowercase <I>mud</I>.

<BR></P>

<P>Muds are a cross between a text adventure game and a chat line. Muds contain a number of rooms, each having a description and possibly containing objects that players can use. Players of the mud&#151;known as <I>mudders</I>&#151;move from room to room 
around the mud. They can pick up objects and use them, meet and talk to other players, solve puzzles, play games, read mud newspapers, combat monsters, and explore virtual reality.

<BR></P>

<P>Muds are becoming more and more mainstream. Once the bastion of male computer science students who also liked a good role-playing game from time to time, they now attract all sorts of people from many walks of life. On a mud, you can bump into someone, 
male or female, who is a film director in real life, or perhaps an English professor, a high school teacher, a sociologist or an engineer&#151;all in the same room! <I>Newsweek</I> magazine, for instance, has mentioned muds several times in its new 
Cyberscope Department, a page-long collection of short articles related to Cyberspace.

<BR></P>

<P>There are some graphical muds being developed, but the vast majority are text-based. Some muds emphasize social aspects; others emphasize combat. On social muds, players tend to use the mud as a communication medium. Players talk to other players, 
create and play games, and join group discussions. On combat muds, players buy weapons and armor, join guilds, learn skills, and fight monsters to gain experience. With enough experience, a player can become a wizard on the mud. Wizards have the ability to 
create new objects, rooms, and puzzles on combat muds.

<BR></P>

<P>There are several major types of muds, such as MUCKs, MUSHes, MOOs, MUSEs, LP-MUDs, Diku-MUDs, and others. Each type of mud differs in the underlying programming environment. Sometimes you will see the word <I>mud</I> expressed as MU* in newsgroups and 
research papers. This is due to the various mud types that have those two letters in the beginning of their names.

<BR></P>

<P>Which type of mud you end up programming for (also known as <I>building</I>), often depends as much on happenstance as on deliberate decision. After all, one tends to hang out wherever one's friends hang out. But there are distinct differences from one 
variety of mud to the next, in both the structure of their programming languages and in the kind of players and builders they tend to attract. For what it's worth, just about any kind of virtual environment <I>could </I>be created in any of the mud 
languages, and yet certain languages have developed genre- or function-based followings, and have evolved further than other, lesser-used types of muds.

<BR></P>

<H3><A ID="I5" NAME="I5">

<FONT SIZE=4><B>Chapter Overview</B>

<BR></FONT></A></H3>

<P>This chapter describes how to use and program several different types of muds: MUCKs, MUSHes, MUSEs and MOOs. LP-MUDs and Diku-MUDs, which are also very popular, are not discussed here. Many small examples will be presented throughout the chapter.

<BR></P>

<P>If you are totally new to muds, you might want to begin by reading through &quot;Interactive Multi-User Realities: MUDs, MOOs, MUCKs and MUSHes,&quot; which can be found in <I>The Internet Unleashed</I>, an earlier SAMS book. That chapter describes mud 
basics in more detail. It describes several resources you can use on the Internet, such as newsgroups and FTP directories, to obtain more information on muds. It also details mud history and reflects on various social issues involving muds.

<BR></P>

<P>Here is a quick outline of mud expertise. It gives a few broad categories of mud programming knowledge so that you can see where your overall skills currently lie.

<BR></P>

<UL>

<LI>Novice

<BR>

<BR>Connects to a mud for the first time.

<BR>

<BR>Uses a &quot;guest&quot; character.

<BR>

<BR></LI>

<LI>Beginner

<BR>

<BR>Knows how to connect to a mud.

<BR>

<BR>Has his or her own character.

<BR>

<BR>Knows common mud commands such as talking, acting, looking, and moving.

<BR>

<BR>Uses some type of mud client program.

<BR>

<BR></LI>

<LI>Intermediate

<BR>

<BR>Knows about at-commands.

<BR>

<BR>Knows about the various flags available on objects in a mud.

<BR>

<BR>Has tried building a few rooms on a mud.

<BR>

<BR>Has programmed a few objects to have basic descriptions and attributes.

<BR>

<BR>Has used functions and simple switch commands in object programs.

<BR>

<BR></LI>

<LI>Advanced

<BR>

<BR>Has programmed an object with user-defined commands and user-defined attributes.

<BR>

<BR>Understands the queue, semaphores, and time synchronization.

<BR>

<BR>Has programmed a reasonably complex object.

<BR>

<BR></LI>

<LI>Expert

<BR>

<BR>Has built whole sections of a mud that contain interlocking puzzles and themes.

<BR>

<BR>Has constructed very complex objects and commands, such as a mud e-mail system or a multi-player poker game.

<BR>

<BR>Administers a mud.

<BR>

<BR></LI></UL>

<P>This chapter deals with beginner, intermediate, and some advanced levels. First, a quick summary of basic mud commands is presented. Following this is a tutorial that talks about intermediate and advanced mud programming issues in a step-by-step manner. 
Many examples, throughout the tutorial, will help you understand the concepts presented. After the tutorial, there is a detailed reference of mud commands, attributes, functions, and flags.

<BR></P>

<H3><A ID="I6" NAME="I6">

<FONT SIZE=4><B>Notation</B>

<BR></FONT></A></H3>

<P>Throughout this chapter, commands and actions that you actually type will appear in monospaced type, and <I>italicized </I>type for placeholder terms for which you supply the appropriate item.

<BR></P>

<P>In addition, examples will use the &gt; character as your prompt on the mud, to denote the commands you type as opposed to the messages the mud sends back to you. In those examples, you don't actually type the &gt; character.

<BR></P>

<P>A | (vertical line) indicates two or more options exist. Choose one. Don't type the |.

<BR></P>

<P>Terms in [] (brackets) denote optional arguments. Don't type the brackets.

<BR></P>

<P>Finally, throughout this chapter, you will be using a character named Speedy.

<BR></P>

<H3><A ID="I7" NAME="I7">

<FONT SIZE=4><B>Overview of Common Mud Commands</B>

<BR></FONT></A></H3>

<P>Each type of mud has its own set of commands, and these commands differ from mud to mud. However, there are several common commands that you can expect no matter which type of mud you use. To refresh your memory, here is a quick summary of some basic 
commands you should know.

<BR></P>

<H4><A ID="I8" NAME="I8">

<FONT SIZE=3><B>Connecting to the Mud</B>

<BR></FONT></A></H4>

<H3><A ID="I9" NAME="I9">

<FONT SIZE=4><B>You can connect to the mud using telnet:</B>

<BR></FONT></A></H3>

<PRE>telnet <I>machine-name</I> <I>port-number</I></PRE>

<P>However, most mudders use some kind of mud client program, which interprets and displays mud messages to them in a nicely formatted fashion.

<BR></P>

<H4><A ID="I10" NAME="I10">

<FONT SIZE=3><B>Connecting to a Character</B>

<BR></FONT></A></H4>

<P>To connect to your character after you are on the mud, you type:

<BR></P>

<PRE>&gt; connect <I>character</I> <I>password</I></PRE>

<P>Some muds take care of password entry&#151;or even the entire login sequence&#151;for you. Just follow the prompts.

<BR></P>

<P>On most muds, you have to send e-mail to the mud administrator in order for him or her to create a character for you to play. Most muds provide for a &quot;guest&quot; character also, so that you can explore the mud a bit before deciding to establish a 
real presence there.

<BR></P>

<H4><A ID="I11" NAME="I11">

<FONT SIZE=3><B>Obtaining Help</B>

<BR></FONT></A></H4>

<P>To access the help facilities on your mud, use:

<BR></P>

<PRE>&gt; help</PRE>

<H3><A ID="I12" NAME="I12">

<FONT SIZE=4><B>This may lead to more specific help topics. You can type</B>

<BR></FONT></A></H3>

<PRE>&gt; help <I>topic</I></PRE>

<P>to obtain help on just about everything in the mud, such as commands, attributes, functions, and various general topics.

<BR></P>

<H4><A ID="I13" NAME="I13">

<FONT SIZE=3><B>Talking</B>

<BR></FONT></A></H4>

<P>This command allows you to talk to other players, and other players to talk to you. The text you speak is transmitted, publicly, to everyone else in the room with you.

<BR></P>

<P>On most muds, the command to speak out loud to other players is the double-quote (&quot;):

<BR></P>

<PRE>&gt; &quot;<I>message</I></PRE>

<P>You do not need to put a double-quote at the end of your message. The mud puts that in for you.

<BR></P>

<PRE>&gt; &quot;Hey, what's for dinner?</PRE>

<P>You say, &quot;Hey, what's for dinner?&quot;

<BR></P>

<H4><A ID="I14" NAME="I14">

<FONT SIZE=3><B>Acting out Actions</B>

<BR></FONT></A></H4>

<P>In addition to speaking, you can act out actions on the mud. These actions create a kind of narrative element to the mud environment, and allow you to express yourself in a different manner than merely speaking.

<BR></P>

<P>On many muds, the act command is the colon (:):

<BR></P>

<PRE>&gt; :message</PRE>

<P>This command will append your message to your name and then display that to everyone in the room.

<BR></P>

<PRE>&gt; :ran a marathon yesterday.</PRE>

<P>Speedy ran a marathon yesterday.

<BR></P>

<H4><A ID="I15" NAME="I15">

<FONT SIZE=3><B>Looking at Objects</B>

<BR></FONT></A></H4>

<P>The command to look at an object is:

<BR></P>

<PRE>&gt; look <I>object</I></PRE>

<P>When you perform this command, the object's description is shown to you. If you leave off the object portion, the mud assumes you want to see the description of the current room. The look command can be abbreviated to l.

<BR></P>

<PRE>&gt; l book</PRE>

<P>You see a musty, leather-bound tome.

<BR></P>

<PRE>&gt; l

Library</PRE>

<P>You are in the library of the house. You can see several bookshelves filled with dusty books lining the walls of the room.

<BR></P>

<H4><A ID="I16" NAME="I16">

<FONT SIZE=3><B>Moving Around</B>

<BR></FONT></A></H4>

<P>To move around from room to room on a mud, you use:

<BR></P>

<PRE>&gt; go <I>direction</I></PRE>

<P>To move to a specific place, use:

<BR></P>

<PRE>&gt; go <I>place</I></PRE>

<P>You can also move in a particular direction by typing that direction, such as:

<BR></P>

<PRE>&gt; north</PRE>

<P>There may be several possible directions or places to move from each room. The best muds are very good at clearly denoting the exits from rooms in the mud.

<BR></P>

<H4><A ID="I17" NAME="I17">

<FONT SIZE=3><B>Whispering to Other Players</B>

<BR></FONT></A></H4>

<P>To send a message secretly to another player in the same room, use the whisper command. This command differs from mud to mud:

<BR></P>

<PRE>&gt; whisper <I>player</I> = <I>message         </I>(MUSH, MUCK, MUSE)

&gt; whisper &quot;<I>message</I>&quot; to <I>player      </I>(MOO)</PRE>

<P>This command has an abbreviation: w.

<BR></P>

<H4><A ID="I18" NAME="I18">

<FONT SIZE=3><B>Paging other Players</B>

<BR></FONT></A></H4>

<P>To send a secret message to another player not in the same room as you, use the page command. This command differs from mud to mud.

<BR></P>

<PRE>&gt; page <I>player</I> = <I>message            </I>(MUSH, MUCK, MUSE)

&gt; page <I>player &quot;message&quot;            </I>(MOO)</PRE>

<P>This command has an abbreviation: p.

<BR></P>

<P>On some muds, the page command costs virtual money, whereas the whisper command is free.

<BR></P>

<H4><A ID="I19" NAME="I19">

<FONT SIZE=3><B>Picking up Objects</B>

<BR></FONT></A></H4>

<P>The command to pick up an object is:

<BR></P>

<PRE>&gt; get <I>object</I></PRE>

<P>If the object can be taken, it is placed into your inventory.

<BR></P>

<P>On some muds, the command is also known as take.

<BR></P>

<H4><A ID="I20" NAME="I20">

<FONT SIZE=3><B>Dropping Objects</B>

<BR></FONT></A></H4>

<P>The command to drop an object is:

<BR></P>

<PRE>&gt; drop <I>object</I></PRE>

<P>The object will be removed from your inventory and placed in your current room.

<BR></P>

<P>On some muds, the command is also known as put.

<BR></P>

<H4><A ID="I21" NAME="I21">

<FONT SIZE=3><B>Listing What You Are Carrying</B>

<BR></FONT></A></H4>

<P>To see a list of the objects you are carrying, use:

<BR></P>

<PRE>&gt; inventory</PRE>

<P>This can be abbreviated to i.

<BR></P>

<PRE>&gt; i

You are carrying:

     a rose

     an envelope containing:

          a letter

     some chocolates</PRE>

<H4><A ID="I22" NAME="I22">

<FONT SIZE=3><B>Finding out Who Else Is Playing the Mud</B>

<BR></FONT></A></H4>

<P>The command to see who else is on the mud varies from mud to mud:

<BR></P>

<PRE>&gt; WHO                              (MUSHes, MUCKs, MUSEs)

&gt; @who                             (MOOs)</PRE>

<H4><A ID="I23" NAME="I23">

<FONT SIZE=3><B>Returning to Your Home</B>

<BR></FONT></A></H4>

<P>The command to return to your place of origin in the mud is:

<BR></P>

<PRE>&gt; home</PRE>

<P>When you first begin playing a mud, your place of origin is usually a standard home room. Later, you can create your own room and reset your home room to it.

<BR></P>

<H4><A ID="I24" NAME="I24">

<FONT SIZE=3><B>Quitting the Mud</B>

<BR></FONT></A></H4>

<P>The command to quit playing varies from mud to mud:

<BR></P>

<PRE>&gt; QUIT                             (MUSHes, MUCKs, MUSEs)

&gt; @quit                            (MOOs)</PRE>

<H3><A ID="I25" NAME="I25">

<FONT SIZE=4><B>How to Program MUCKs, MUSHes, and MUSEs: A Tutorial</B>

<BR></FONT></A></H3>

<P>This section discusses most of the key topics you should be familiar with as a MUCK, MUSH or MUSE programmer. Most of the concepts apply to all of the MU* environments; however, there are a few topics that only apply to certain types of muds. These 
topics will be labeled as such in the text.

<BR></P>

<P>MUCK is the most basic of the three types of muds that are discussed in this section. MUSH is more advanced than MUCK, and MUSE can be thought of as MUSH with a few extensions.

<BR></P>

<P>Thanks go to Lydia &quot;Amberyl&quot; Leong for the mud help document upon which this section is based.

<BR></P>

<H4><A ID="I26" NAME="I26">

<FONT SIZE=3><B>Objects</B>

<BR></FONT></A></H4>

<P>MUCKs, MUSHes and MUSEs have four basic types of things: <I>rooms</I>, <I>players</I>, <I>exits</I>, and <I>objects</I>. You can think of rooms, players, and exits as special objects that have added capabilities. Rooms are the building blocks of the 
mud. You move through the rooms in the mud in order to explore it and meet other people. Players are the people that you meet. You, of course, are a player, and there may be many more players, besides yourself, playing the mud at the same time. Exits 
connect rooms to each other. Finally, objects are everything else in the mud. You can create objects yourself and program them to behave in many ways.

<BR></P>

<H4><A ID="I27" NAME="I27">

<FONT SIZE=3><B>DBREF</B>

<BR></FONT></A></H4>

<P>Every object in the mud has a database reference number, known as its <I>DBREF</I>. This number can be used to access properties and attributes on the object.

<BR></P>

<P>Most commands will accept either names or DBREF as object specifiers, but some will insist on one or the other. Try it both ways if you get stuck.

<BR></P>

<H4><A ID="I28" NAME="I28">

<FONT SIZE=3><B>Money</B>

<BR></FONT></A></H4>

<P>Most muds have their own monetary system. As you wander around the mud, from room to room, you may find gold coins or other monetary types. You can then use this money to create new objects, build rooms, and other such activities&#151;since many of 
these activities require a small amount of money to be used.

<BR></P>

<P>Different muds have different types of money, such as gold coins, drachmas, cookies, pennies, dollars, or a fictional type like &quot;blabooies.&quot; This chapter uses credits as the monetary unit in its examples.

<BR></P>

<H4><A ID="I29" NAME="I29">

<FONT SIZE=3><B>Wizards and Officials</B>

<BR></FONT></A></H4>

<P>Throughout this chapter, you may see the term <I>wizard</I> or <I>official</I>. Wizards are players in the mud who have special abilities. Frequently, the wizard is the person who is actually running the mud on their machine. However, there may be other 
wizards who help the mud administrator, with such things as character creation, policing the mud, and keeping the environment consistent. On MUSEs, wizards are called officials.

<BR></P>

<P>Some commands in the mud are only available to wizards. These commands will be identified as such where appropriate.

<BR></P>

<H4><A ID="I30" NAME="I30">

<FONT SIZE=3><B>At-Commands</B>

<BR></FONT></A></H4>

<P>Some commands and attributes in the mud start with an &quot;at&quot; symbol (@), such as the command to teleport from one room to another, @teleport. These commands and attributes are collectively known as <I>at-commands</I>.

<BR></P>

<H4><A ID="I31" NAME="I31">

<FONT SIZE=3><B>Flags</B>

<BR></FONT></A></H4>

<P>There are several <I>flags</I> that you can set in a MUSH. The syntax for setting a flag is:

<BR></P>

<PRE>&gt; @set <I>object</I> = <I>flag</I>               (To turn the flag ON)

&gt; @set <I>object</I> = ! <I>flag</I>             (To turn the flag OFF)</PRE>

<P>Throughout this section, different flags will be mentioned as appropriate.

<BR></P>

<H4><A ID="I32" NAME="I32">

<FONT SIZE=3><B>Messages</B>

<BR></FONT></A></H4>

<P>In addition to speaking and acting, you can write messages directly to other players using the emit command: @emit <I>message</I>. The message you type will be sent to everyone in the room, including you. As an abbreviation, you can type: \\ 
<I>message</I>. There are a few variants of this command. @pemit <I>player</I> = <I>message</I> will display the message only to the player specified. @oemit <I>player</I> = <I>message</I> displays the message to everyone in the room <I>except</I> the 
player specified.

<BR></P>

<P>An emitted message does not print who emitted it. If you want to always see who caused an emitted message, you can turn on your NOSPOOF flag. Upon doing so, you will be informed of the player or object that causes an emitted message.

<BR></P>

<P>Another flag is the HAVEN flag. When this is set on a player, the player will not receive pages or @pemit messages. If you try to page a player with HAVEN set, you will be told that that player is not accepting pages. This flag does not black out @emit 
messages, however.

<BR></P>

<P>To find out where a player is located, use the @whereis <I>player</I> command. This command will display the room where the player is. After the player is located, he or she is given a message that you are looking for him or her. If you do not want to 
be located, set yourself to DARK.

<BR></P>

<P>These commands are not available in MUCK.

<BR></P>

<H4><A ID="I33" NAME="I33">

<FONT SIZE=3><B>Creating and Naming Objects</B>

<BR></FONT></A></H4>

<P>To create a new object in the mud, type:

<BR></P>

<PRE>&gt; @create <I>object-name</I> = <I>cost</I></PRE>

<P>If you leave off the cost, the object will be created with the default cost, usually 10 credits. After checking to make sure you have enough money to create the object, the mud will respond with the message &quot;<I>Object</I> created as object 
#<I>DBREF</I>&quot; and the object will be placed into your inventory. You can now refer to this object by using either its object name or it's DBREF. The MUSH performs pattern-matching, so you only need to type enough of the object name to differentiate 
it from other objects you may be holding.

<BR></P>

<P>If you change your mind and you want to rename an object, use:

<BR></P>

<PRE>&gt; @name <I>old-object-name</I> = <I>new-object-name</I></PRE>

<P>To change your own name, you can use

<BR></P>

<PRE>&gt; @name me = <I>new-name password</I></PRE>

<H4><A ID="I34" NAME="I34">

<FONT SIZE=3><B>Attributes</B>

<BR></FONT></A></H4>

<P>Now that you have created an object, you can set its description. The description of an object is one of the <I>attributes</I> that an object can have. An attribute is simply a property on an object.

<BR></P>

<P>There are several types of descriptions. @desc <I>object</I> = <I>description</I> sets the description that is displayed to the player that is looking at the object. @odesc <I>object</I> = <I>description</I> is displayed to everyone except the person 
looking at the object. The player's name and a space are prepended to the message specified. The command @adesc <I>object</I> = <I>actions</I> sets a list of actions that are executed by the mud when the object is looked at.

<BR></P>

<P>At this point, it is useful to take note of the basic forms that attributes take throughout MUSH. Assume there is an attribute with the name @xxx. It is applied to the player that is dealing with the object. In addition to the basic attribute, there are 
usually additional attributes that correspond to the basic attribute. @oxxx is applied to everyone <I>except</I> the player dealing with the object, and @axxx runs a list of actions when the object is used is some fashion. Familiarizing yourself with the 
@xxx / @oxxx / @axxx combination of attribute names will help you understand and remember other attribute names, since they are similar.

<BR></P>

<P>MUCKs, in general, don't have the @axxx attributes, and usually do not have as many @xxx and @oxxx attributes as MUSHes and MUSEs do.

<BR></P>

<P>When an object is picked up, its @succ attribute is triggered&#151;&quot;succ&quot; is short for &quot;success&quot;. To set the success attribute on an object, use @succ <I>object</I> = <I>message</I>. When the object is picked up, the message will be 
displayed to the player who took it. The @osucc attribute sets the message displayed to players other than the player who took the object, and the @asucc attribute can be used to set actions that you want performed when the object is taken.

<BR></P>

<P>Conversely, the @fail attribute is triggered when a player fails to pick up an object, and the @ofail and @afail attributes correspond appropriately. Usually, a player fails to pick up an object because an object is locked.

<BR></P>

<P>It is frequently a good idea to lock an object since unlocked objects can be stolen from you. To lock an object to yourself, use:

<BR></P>

<PRE>&gt; @lock <I>object</I> = me</PRE>

<P>This will allow only you to pick up the object. In a more general form, the lock command is:

<BR></P>

<PRE>&gt; @lock <I>object</I> = <I>key</I></PRE>

<P>The key can be an object name, or a DBREF, or the special words &quot;me&quot; or &quot;here.&quot; Boolean expressions are allowed. If you want the key to be a player, you must prefix the player name to an asterisk (*), as in @lock spinach = *Popeye.

<BR></P>

<P>Locks are related to the @succ (success) and @fail (failure) attributes in that successfully passing a lock will trigger @succ and failing the lock test will trigger @fail.

<BR></P>

<P>To unlock an object, use @unlock <I>object</I>.

<BR></P>

<P>The @drop attributes set the messages that are displayed when an object is dropped. Using @drop <I>object</I> = <I>message</I> sets the message displayed to the player who drops the object. @odrop is the message displayed to others, and @adrop are the 
actions performed when the object is dropped

<BR></P>

<P>The @move attributes are triggered when the player or object on which they are set moves from one room to another. The @move, @omove and @amove behave as you would expect.

<BR></P>

<P>To destroy an object that you own, use @destroy <I>object-name</I>. You will be paid whatever it cost you to create the object. Destroying objects when you don't need them anymore helps free up space in the mud database. If you want to give anyone the 
ability to destroy an object that you have created, turn on its DESTROY_OK flag.

<BR></P>

<P>If you want other players to be able to see how you have programmed an object, set the object VISUAL.

<BR></P>

<PRE>&gt; @create root beer float

root beer float created as object #1765.

&gt; inventory

You are carrying:

root beer float (#1765).

You have 921 credits.

&gt; @desc root = You see a frosted mug of root beer with a dollop of vanilla ice cream floating in it.

Set.

&gt; @succ root = You pick up the frosted mug.

Set.

&gt; @osucc root = picks up the mug of root beer.

Set.

&gt; @drop root = You put down the frosted mug.

Set.

&gt; @odrop root = puts down the mug of root beer.

Set.

&gt; drop root beer float

You put down the frosted mug.

&gt; look root beer float

root beer float (#1765)

You see a frosted mug of root beer with a dollop of vanilla ice cream floating in it.

&gt; get root beer float

You pick up the frosted mug.

&gt; @destroy root

You get back your 10 credit deposit for root beer float (#1765).

Destroyed.</PRE>

<P>On most muds, you can type enough of the object name to make it distinguishable from any other object in the room. Thus, in the root beer float example, referring to it as root was sufficient.

<BR></P>

<H4><A ID="I35" NAME="I35">

<FONT SIZE=3><B>Action Lists</B>

<BR></FONT></A></H4>

<P>The @axxx attributes (attributes that start with the letter <I>a</I>) are used to execute action lists. An action list is simply a list of one or more actions, separated by semicolons. For example, you could create a fragile vase. When it is dropped, it 
does two things: it prints a message describing how it shatters, and then it destroys itself.

<BR></P>

<PRE>&gt; @adrop vase = @emit The fragile vase shatters.;@destroy me

Set.

&gt; drop vase

The fragile vase shatters.

fragile vase has left.

You get back your 10 credit deposit for fragile vase (#1238).</PRE>

<P>Actions lists are not available in MUCK.

<BR></P>

<H4><A ID="I36" NAME="I36">

<FONT SIZE=3><B>Examining</B>

<BR></FONT></A></H4>

<P>In addition to the basic look command, you can also examine items in the mud. Examining an object provides you with more detailed information about the object. The command to examine an object (or player) is:

<BR></P>

<PRE>&gt; examine <I>object</I></PRE>

<P>If you do <I>not</I> control the object, the examine command will tell you the owner of the object and show any public attributes on the object, such as its description, its success and fail attributes, and so forth.

<BR></P>

<P>If you <I>do</I> own the object, or if the object has its VISUAL flag set, you will be able to see all the attributes and how they are programmed.

<BR></P>

<P>You will also see any objects that are inside the object you are looking at&#151;provided that the containing object is not set OPAQUE.

<BR></P>

<P>If you set an object DARK, it will not show up in a room's contents list. If a player is set DARK, no one will be able to see what that player is carrying.

<BR></P>

<H4><A ID="I37" NAME="I37">

<FONT SIZE=3><B>More Movement Commands</B>

<BR></FONT></A></H4>

<P>You can teleport from one room to another by using the teleport command. You can only teleport into rooms that are set JUMP_OK.

<BR></P>

<PRE>&gt; @tel <I>room-number</I></PRE>

<P>You can also teleport objects that you own into rooms that are JUMP_OK:

<BR></P>

<PRE>&gt; @tel <I>object</I> = <I>room-number</I></PRE>

<P>So, if you know that a meeting place that you want to go to is room #222, you could get there by typing:

<BR></P>

<PRE>&gt; @tel #222</PRE>

<P>If an undesirable player or object is in a room that you own, you can teleport it out of your room to any other room that is JUMP_OK. You could also teleport it to any other room that is yours. So, if someone barges into your room, where you are having 
a private conversation with someone, and they won't leave, you can get rid of them!

<BR></P>

<P>You can also get rid of them by more violent method of killing them.

<BR></P>

<H4><A ID="I38" NAME="I38">

<FONT SIZE=3><B>Killing</B>

<BR></FONT></A></H4>

<P>Killing, in general, is frowned upon. In fact, some muds don't allow player killing. However, one must remember that muds are only games. So, if someone is being obnoxious, and won't stop, sometimes the only way to drive your displeasure home is to kill 
them off. The command to do this is:

<BR></P>

<PRE>&gt; kill <I>thing</I> = <I>money</I></PRE>

<P>The default cost of killing something is 10 credits. This gives you a 10% chance of success. For each additional credit you spend, your chance of success goes up 1%. Spending 100 credits gives you a 100% chance of success.

<BR></P>

<P>Killing something sends it home. The object killed is also paid half the amount of money used to kill it, as a sort of insurance policy.

<BR></P>

<P>When an object is killed, the @kill, @okill, and @akill attributes are triggered. They work as you would expect.

<BR></P>

<P>Certain things, such as wizards or objects set IMMORTAL, cannot be killed. Only wizards can set things IMMORTAL.

<BR></P>

<H4><A ID="I39" NAME="I39">

<FONT SIZE=3><B>Giving and Receiving Objects</B>

<BR></FONT></A></H4>

<P>Occasionally, you may want to give another player an object that you have. Or perhaps you want to give them some money. The commands to do these things are:

<BR></P>

<PRE>&gt; give <I>player</I> = <I>object</I>

&gt; give <I>player</I> = <I>money</I></PRE>

<P>The player who is receiving the object must have their ENTER_OK flag set.

<BR></P>

<P>Conversely, you can take an object from another player by using the possessive form of the get command:

<BR></P>

<PRE>&gt; get <I>player</I>'s <I>object</I></PRE>

<P>The player who is holding the object must be set ENTER_OK, and the object that you are trying to take cannot be locked against you. This is another reason to use locks on objects. If you don't lock an object, someone else can steal it from you!

<BR></P>

<P>Sometimes, instead of just giving a player an object, you many want to allow some other player to own an object that you have created. In order to do this, you must first allow your object to have its ownership changed by setting it CHOWN_OK. You can 
then give the object to someone else. The player who receives the object may then change its owner by using the change ownership command, @chown <I>object</I> = me.

<BR></P>

<H4><A ID="I40" NAME="I40">

<FONT SIZE=3><B>Finding and Searching for Objects</B>

<BR></FONT></A></H4>

<P>In a mud with lots of rooms and objects, you might end up losing one of your objects and forgetting where it is. The @find <I>string</I> command will scan through the database and pick out all objects and rooms that have the given string in their names. 
It prints out the object name and DBREF. @find without any arguments displays all the objects and rooms in the mud that you own. However, it can cost a lot because it takes a lot of computations. Here are some examples

<BR></P>

<PRE>@find dog

@find Speedy</PRE>

<P>Related to the find command is the search command, @search. It scans through the mud and prints everything about an object. There are several arguments you can give to this command: @search <I>player</I> will display all the objects owned by that 
player. @search type =<I> object-type</I> will display objects that have that type. For <I>object-type</I>, you can use the types: rooms, exits, objects, or players. @search <I>string</I> searches for that string. And @search flags = <I>flags-desired</I> 
will search for those flags. Here are some examples:

<BR></P>

<PRE>@search Speedy

@search type = objects

@search dog

@search flags = D</PRE>

<P>If you want to make sure you don't lose an object, you can link it to yourself. First, set its home to yourself by using the command @link <I>object</I> = me. Then, turn on the object's STICKY flag. STICKY objects are sent home when they are dropped. 
Thus, when the object is dropped, it will return to you.

<BR></P>

<PRE>&gt; @link homing pigeon = me

&gt; @set homing pigeon = STICKY</PRE>

<P>If someone then takes the pigeon, and later lets it go by dropping it, it will return to you.

<BR></P>

<H4><A ID="I41" NAME="I41">

<FONT SIZE=3><B>Rooms and Exits</B>

<BR></FONT></A></H4>

<P>In addition to objects and players, you can also create your own rooms, complete with their own descriptions.

<BR></P>

<P>As an example, consider building a tree with a treehouse in it. The tree will be in the middle of a field. The treehouse will have a balcony outside.

<BR></P>

<P>The field room already exists. It has been set LINK_OK. The example will describe how to create the tree, the treehous,e and the balcony. It will then describe how to link the three rooms to the existing field.

<BR></P>

<P>It helps to form a mental picture of the scene you wish to create. This is expressed in Figure 11.1. From the mental image, you can generalize the scene into objects, rooms, and exits, as seen in Figure 11.2.

<BR></P>

<P>

<BR><B><A HREF="08tig01.gif">Figure 11.1. This is the conceptual idea of the scene.</A></B>

<BR></P>

<P>

<BR><B><A HREF="08tig02.gif">Figure 11.2. Here are the generalized rooms and exits of the scene.</A></B>

<BR></P>

<P>Now that you have an idea of what you are trying to accomplish, you can begin to create it. To create a room, use the dig command:

<BR></P>

<PRE>&gt; @dig <I>room-name</I></PRE>

<P>This creates a room with that name. The mud responds with a message informing you of the DBREF of the room.

<BR></P>

<P>Following the example, create the Tree:

<BR></P>

<PRE>&gt; @dig Tree

Tree created with room number #1442.

&gt; @tel #11442

Tree (#1442R)

&gt; @desc #1442=You see a large tree. There seems to be a treehouse up in the branches.

Set.</PRE>

<P>The descriptions used here are simplistic because the focus here is room construction. In a real mud, though, a more eloquent description would better convey the sense of the scenery.

<BR></P>

<P>This room will initially be disconnected from everything else. You can think of it as floating in hyperspace. You can then teleport into that room using the @tel command and set its description and other attributes. However, if your room is not linked 
to other rooms, you may get a message from time to time indicating that you have an unconnected room. To turn off the message, set the room's FLOATING flag.

<BR></P>

<P>Rooms are connected to each other using exits. Exits are the links between rooms. You can create exits by using qualifiers with the @dig command, or by creating them directly with the @open command.

<BR></P>

<P>The format to create exits with the @dig command at the same time you create rooms is:

<BR></P>

<PRE>&gt; @dig <I>room-name</I> = <I>in1;in2;in3;...</I> , <I>out1;out2;out3;...</I></PRE>

<P>In this command, the <I>in1;in2;in3;...</I> names are names of entrances into the new room. Each name in the in-list is an alias for the entrance. The <I>out1;out2;out3;...</I> names are the names of exits from the new room back into your current room. 
Each name in the out-list is an alias for the exit. The first name in the list of entrances, <I>in1</I>, will be used as the name in the Obvious exits of the current room. The first name in the list of exits, <I>out1</I>, will be used in the Obvious exits 
of the new room.

<BR></P>

<P>You can specify as many of these entrance and exit names as you wish; just remember to separate them with semicolons. Note that the list of entrance names is separated from the list of exit names by a comma.

<BR></P>

<P>Two links are created in the @dig command above. One link goes from the current room to the new room, and uses the in-list names. That's the entrance to the new room. The other link goes from the new room back into the current room, and uses the 
out-list names. That's the exit from the new room.

<BR></P>

<P>You can use the @dig command with exit names to create the treehouse and the deck in the example. Assume you are in the Tree room:

<BR></P>

<PRE>&gt; l

Tree (#1442R)

You see a large tree. There seems to be a treehouse up in the branches.

&gt; @dig Treehouse=treehouse;house;up;u,tree;down;d

Treehouse created with room number 1443.

Opened.

Linked.

Opened.

Linked.

&gt; l

Tree (#1442R)

You see a large tree. There seems to be a treehouse up in the branches.

Obvious exits:

treehouse</PRE>

<P>Note how the treehouse exit name now appears in the Obvious exits list. That's because it was the first name in the list of entrances into the new room, treehouse;house;up;u.

<BR></P>

<P>You can then move into the treehouse by typing one of the entrance names, such as treehouse, or house, or up, or u. This moves you through the exit, into the new room that you have just created.

<BR></P>

<PRE>&gt; treehouse

Treehouse (#1443R)

Obvious exits:

tree</PRE>

<P>The Obvious exits in the treehouse specifies tree because tree was the first name in the list of exits, tree;down;d, in the @dig command earlier.

<BR></P>

<P>Next, we can describe the treehouse and then create the deck:

<BR></P>

<PRE>&gt; @desc here=You are in a small treehouse near the top of a large tree. A deck can be seen outside.

Set.

&gt; @dig Deck=deck;out,treehouse;house;in

Deck created with room number 1446.

Opened.

Linked.

Opened.

Linked.

&gt; deck

Deck (#1446R)

Obvious exits:

treehouse

&gt; @desc here = You are standing on the deck attached to the treehouse. A field can be seen below.

Set.</PRE>

<P>Now the tree, the treehouse, and the deck have been created. To link the field to the tree and the deck, you can use the @open command to create specific exits

<BR></P>

<PRE>&gt; @open <I>in1;in2;in3;...</I> = #<I>DBREF</I> , <I>out1;out2;out3;...</I></PRE>

<P>which will open an exit from the current room to the room specified by the DBREF. The exit will have the entrance names specified in the in-list. Another exit will go from the DBREF room to the current room, and will have the names specified in the 
out-list.

<BR></P>

<P>You can leave off the out-list. In that case, the exit from the DBREF room to the current room is not created.

<BR></P>

<P>Using the @open command, we can create the exits from the field to the tree:

<BR></P>

<PRE>&gt; @open tree;up;u=#1442,field,down;d

Opened.

Linked.

Opened.

Linked.</PRE>

<P>The messages for opening and linking are indicating to you that both the incoming and outgoing links from the tree to room #1442 have been created.

<BR></P>

<P>Next, we can create the exit from the deck to the field by teleporting to the deck and then using the @open command without an out-list, thereby creating a one-way link from the deck to the field, but not the other way. Assume the field room has a DBREF 
of 1440.

<BR></P>

<PRE>&gt; @tel #1446

Deck (#1446R)

You are standing on the deck attached to the treehouse. A field can be seen below.

Obvious exits:

treehouse

&gt; @open field;jump;down;d=#1440

Opened.

Linked.

&gt; l

Deck (#1446R)

You are standing on the deck attached to the treehouse. A field can be seen below.

Obvious exits:

treehouse field</PRE>

<P>Now the example is complete!

<BR></P>

<H4><A ID="I42" NAME="I42">

<FONT SIZE=3><B>Rooms as Homes</B>

<BR></FONT></A></H4>

<P>To set your home to a particular room, use the @link command:

<BR></P>

<PRE>&gt; @link <I>object</I> = #<I>room-number</I></PRE>

<P>If you are in the room you want to change to your home, you can use the shorthand keyword here in place of the <I>room-number</I><I>:</I>

<BR></P>

<PRE>&gt; @link me = here</PRE>

<P>You can also allow other players to set their homes to one of your rooms by setting that room's ABODE flag. Rooms that are set ABODE may become other players homes.

<BR></P>

<P>In addition, rooms may be linked to other rooms using the same @link command

<BR></P>

<PRE>&gt; @link <I>room</I> = #<I>other-room</I></PRE>

<P>which will make <I>room</I> a so-called &quot;drop-to&quot; room. Objects that are dropped in <I>room</I> are sent to <I>other-room</I>. For instance, in the tree example, you can set the tree's @link to be the field. Then, any object dropped from the 
tree will fall down to the field:

<BR></P>

<PRE>&gt; @tel #1442

Tree (#1442R)

You see a large tree. There seems to be a treehouse up in the branches.

Obvious exits:

treehouse field

&gt; @link here = #1440

Dropto set.

&gt; drop brick

Dropped.

&gt; l

Tree (#1442R)

You see a large tree. There seems to be a treehouse up in the branches.

Obvious exits:

treehouse field

&gt; down

Field (#1440R)

You are standing in the middle of a field. There is a large tree here.

Contents:

brick

Obvious exits:

tree north south east west</PRE>

<P>If a drop-to room is also set to be STICKY, then any objects dropped in it will fall to the next room only when all the players have left the drop-to room. Think of the STICKY flag on a room as a delayed drop-to action.

<BR></P>

<H4><A ID="I43" NAME="I43">

<FONT SIZE=3><B>Examining Exits</B>

<BR></FONT></A></H4>

<P>Exits are really one-way streets from one room to another. To create a path going from one room to another both ways, you actually have to create two exits&#151;one exit going one direction and the other exit going the opposite direction.

<BR></P>

<P>Once an exit is created, it shows up if you examine the room from which it leaves. For instance, if we examined the Deck of the example:

<BR></P>

<PRE>&gt; examine here

Deck (#1446R)

Type: ROOM

You are standing on the deck attached to the treehouse. A field can be seen below.

Owner: Speedy  Key: *UNLOCKED*

Contents:

Speedy (#5Pc)

Field;jump;down;d (#1451E)

Treehouse;house;in (#1448E)</PRE>

<P>Thus, with the examine command, you can see all the exits that are going <I>out of</I> a room.

<BR></P>

<P>You can also get a list of all the links going <I>into</I> a room by typing:

<BR></P>

<PRE>&gt; @entrances #<I>room-number</I></PRE>

<P>This will also show all the objects whose homes are set to that room.

<BR></P>

<PRE>&gt; @entrances here

Treehouse (#1443R) (Deck;out)

1 entrance found.</PRE>

<H4><A ID="I44" NAME="I44">

<FONT SIZE=3><B>Exit Attributes</B>

<BR></FONT></A></H4>

<P>Exits can have the same types of attributes that other objects have, such as @succ or @fail messages. Here is a summary of attributes as they apply to exits:

<BR></P>

<PRE>@succ</PRE>

<P>Message displayed when a player goes through the exit successfully. It is displayed to the player going through the link.

<BR></P>

<PRE>@osucc</PRE>

<P>Message displayed to the other people in the room from which the player is leaving successfully.

<BR></P>

<PRE>@asucc</PRE>

<P>Actions to be executed when a player leaves a room successfully. Not present in MUCK.

<BR></P>

<PRE>@fail</PRE>

<P>Message displayed when a player fails to go through an exit. It is displayed to the player who fails to pass through the link.

<BR></P>

<PRE>@ofail</PRE>

<P>Message displayed when a player fails to go through an exit. It is displayed to the people in the room from which the player is trying to leave.

<BR></P>

<PRE>@afail</PRE>

<P>Actions to be executed when a player fails to exit a link successfully. Not present in MUCK.

<BR></P>

<PRE>@drop</PRE>

<P>This attribute does not apply to exits. It is included here for completeness with the other drop attributes.

<BR></P>

<PRE>@odrop</PRE>

<P>Message displayed to the other people in a room that a player is entering successfully. Not present in MUCK.

<BR></P>

<PRE>@adrop</PRE>

<P>Actions executed when a player enters a room successfully. Not present in MUCK.

<BR></P>

<P>As a rule, you should define the @osucc, @ofail, and @odrop attributes on any exit you create. In this way, a message will be displayed to the people in the room that the player is leaving, and another message will be displayed to the people in the room 
that the player is entering. You can also define the @desc attribute on a exit, so that something is displayed to a player who tries to look at it.

<BR></P>

<H4><A ID="I45" NAME="I45">

<FONT SIZE=3><B>Special Exits</B>

<BR></FONT></A></H4>

<P>Most exits from one room lead into another room. However, you can create special NULL exits that display messages to players rather than move them to different rooms. To do this, create an exit on a room, set its lock to #0, and then set its @fail 
message to the message you want to display when the player types that exit name. You should also set it DARK.

<BR></P>

<P>For example, perhaps you want to display the message You wave to the crowd when the player types the command wave. To accomplish this:

<BR></P>

<PRE>&gt; @open wave = here

Opened.

Linked.

&gt; @lock wave = #0

Locked.

&gt; @fail wave = You wave to the crowd.

Set.

&gt; @set wave = DARK

Set.

&gt; wave

You wave to the crowd.</PRE>

<P>NULL exits can also be used to display a message to the user when he or she tries to move in a direction that does not exist. Normally, when a player tries to move in a non-existent direction, a default Huh? (Type 'help' for help) message is displayed 
to that player. The Huh? message is displayed for any unrecognized command that the player types. A better, more informative message would be something like You cannot go in that direction. To create this, create a NULL exit as mentioned above. Then, for 
the exit's name list, specify the directions for which you want the message to appear.

<BR></P>

<P>For instance, suppose a room only has a north exit. You want to display the You cannot go in that direction message when the player tries to go in a direction other than north. So, create an exit whose name list has all the non-north directions and 
abbreviations, and then set up its @lock and @fail:

<BR></P>

<PRE>&gt; @open east;e;west;w;south;s = here

Opened.

Linked.

&gt; @lock east = #0

Locked.

&gt; @fail east = You cannot go in that direction.

Set.

&gt; @set east = DARK

Set.

&gt; east

You cannot go in that direction.

&gt; west

You cannot go in that direction.

&gt; south

You cannot go in that direction.</PRE>

<H4><A ID="I46" NAME="I46">

<FONT SIZE=3><B>Other Flags on Rooms and Exits</B>

<BR></FONT></A></H4>

<P>To allow people to be able to teleport into your room, set the room JUMP_OK. To allow people to create links that lead <I>into</I> your room, set your room LINK_OK. Note that other players still can't create links that lead <I>out</I> of your 
room&#151;you have to do that.

<BR></P>

<P>The TRANSPARENT flag, when set on an exit, causes the description of the next room to be seen when a player looks at that exit. This allows players to see into adjoining rooms.

<BR></P>

<H4><A ID="I47" NAME="I47">

<FONT SIZE=3><B>Unlinking Exits</B>

<BR></FONT></A></H4>

<P>You can unlink an exit by using the @unlink command:

<BR></P>

<PRE>&gt; @unlink <I>exit</I></PRE>

<P>This will unlink the destination of the exit. You can then relink the destination to some other room using the @link command. Exits become owned by whomever links them, so you shouldn't leave an exit unlinked.

<BR></P>

<H4><A ID="I48" NAME="I48">

<FONT SIZE=3><B>Containers</B>

<BR></FONT></A></H4>

<P>You can create objects that can contain other objects by setting the object ENTER_OK. Then, to go inside the object, use the command:

<BR></P>

<PRE>&gt; enter <I>object</I></PRE>

<P>and to go out of the object, use the command:

<BR></P>

<PRE>&gt; leave</PRE>

<H4><A ID="I49" NAME="I49">

<FONT SIZE=3><B>Enter and Leave Attributes</B>

<BR></FONT></A></H4>

<P>The normal @desc attribute is the description of the container, and it is displayed to players that look at the object from the <I>outside</I>. The @idesc attribute sets the message that is displayed to anyone <I>inside</I> the container who types the 
look command.

<BR></P>

<P>There are several attributes that are triggered when an object is entered by something, or when something exits an object. The @enter attribute is displayed to the entering object, the @oenter attribute is displayed to anyone else inside the object, the 
@oxenter message is displayed to people who are in the room that the player leaves, and the @aenter attribute is a list of actions that are to be executed when an object is entered. The @leave, @oleave, @oxleave, and @aleave attribute correspond similarly 
for objects that are leaving a container.

<BR></P>

<PRE>&gt; @create phone booth

phone booth created as object #999.

Set.

&gt; @desc = You see a telephone booth here.

Set.

&gt; @idesc = You are inside a phone booth. There is a coin-operated telephone attached to one side of the booth.

&gt; @enter phone booth = You enter the phone booth.

Set.

&gt; @oenter phone booth = :squeezes into the phone booth with you.

Set.

&gt; @oxenter phone booth = :enters the phone booth.

Set.

&gt; @leave phone booth = You leave the phone booth.

Set.

&gt; @oleave phone booth = :departs from you, leaving the phone booth.

Set.

&gt; @oxleave phone booth = :leaves the phone booth.

Set.</PRE>

<H4><A ID="I50" NAME="I50">

<FONT SIZE=3><B>Pronoun Substitutions</B>

<BR></FONT></A></H4>

<P>Sometimes you want to create sentences in your attribute messages that depend on the gender or name of the player performing some action on an object. The attributes that begin with @a (such as @asucc, @afail, @adrop, and so forth) frequently use 
special substitutions in their actions.

<BR></P>

<P>For instance, perhaps you want to create a cat that meows when it is dropped. You want to display a message to everyone that the cat meows at him when dropped by a male player, and meows at her when dropped by female player. In addition, you want to use 
the dropping player's name in the message. You can do this using special pronoun substitutions:

<BR></P>

<PRE>&gt; @adrop cat = %N drops the cat, which lands on the ground and meows at %o.</PRE>

<P>In the preceding message, the player's name is substituted for the %N portion of the message, and the objective form of the player's name is substituted for the %o part of the message. In this manner, a male player named Linus would trigger a message 
Linus drops the cat, which lands on the ground and meows at him, while a female player named Lucy would trigger the message Lucy drops the cat, which lands on the ground and meows at her. The mud determines which pronoun to substitute by looking at the 
gender of the player, which is stored in the @sex attribute.

<BR></P>

<P>There are several types of pronoun substitutions:

<BR></P>

<PRE>%N, %n</PRE>

<P>Substitutes the player's name. %N is the capitalized form; %n is not capitalized.

<BR></P>

<PRE>%S, %s</PRE>

<P>Substitutes the subjective form of the player's name (he/she/it/they). %S capitalizes the first letter; %s does not.

<BR></P>

<PRE>%O, %o</PRE>

<P>Substitutes the objective form of the player's name (him/her/it/them). %O capitalizes the first letter; %o does not.

<BR></P>

<PRE>%P, %p</PRE>

<P>Substitutes the possessive form of the player's name (his/her/its/their). %P capitalizes the first letter; %p does not.

<BR></P>

<PRE>%A, %a</PRE>

<P>Substitutes the absolute possessive form of the player's name (his/hers/its/theirs). %A capitalizes the first letter; %a does not.

<BR></P>

<H4><A ID="I51" NAME="I51">

<FONT SIZE=3><B>Try It Out!</B>

<BR></FONT></A></H4>

<P>This information is enough to get you started on creating objects, setting some of their attributes, building some rooms and linking them up with exits, and making your own little virtual world.

<BR></P>

<P>The next few sections will describe some specifics for several types of muds: MUCKs, MUSHes, and MUSEs.

<BR></P>

<H3><A ID="I52" NAME="I52">

<FONT SIZE=4><B>Programming a MUCK</B>

<BR></FONT></A></H3>

<P>MUCK, which is a pun on the term MUD, is a spin-off of the original TinyMUD. This section describes TinyMUCK version 2.2.

<BR></P>

<H4><A ID="I53" NAME="I53">

<FONT SIZE=3><B>Popular MUCKs</B>

<BR></FONT></A></H4>

<P>There are many popular MUCKs on the Internet. Some of them were among the first muds to appear on the Internet and, as a result, have a large population of longtime mud players.

<BR></P>

<TABLE BORDER>

<TR>

<TD>

<PRE><B><I>Name</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Machine Name</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Internet </I></B><B><I>Address</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Port</I></B>

<BR></PRE>

<TR>

<TD>

<P>AnimeMUCK</P>

<TD>

<P>anime.tcp.com</P>

<TD>

<P>128.95.10.106</P>

<TD>

<P>2035</P>

<TR>

<TD>

<P>CaveMUCK</P>

<TD>

<P>cave.tcp.com</P>

<TD>

<P>128.95.44.29</P>

<TD>

<P>2283</P>

<TR>

<TD>

<P>FurryMUCK</P>

<TD>

<P>sncils.snc.edu</P>

<TD>

<P>138.74.0.10</P>

<TD>

<P>8888</P>

<TR>

<TD>

<P>NAILS</P>

<TD>

<P>flounder.rutgers.edu</P>

<TD>

<P>128.6.128.5</P>

<TD>

<P>5150</P></TABLE>

<P>FurryMUCK, one of the earliest muds, harbors a large group of devoted players. Its theme is anthropomorphic animals&#151;characters that are animals with human characteristics.

<BR></P>

<P>These addresses are current as of August, 1994. Keep in mind that they may change.

<BR></P>

<H3><A ID="I54" NAME="I54">

<FONT SIZE=4><B>Things Specific to MUCKs</B>

<BR></FONT></A></H3>

<P>From the player's standpoint, MUCKs operate similarly to other types of mud on the Net. Beneath the visible text, however, programmers will find that they are significantly different. This section indicates some of the principle features of programming 
in MUCKs.

<BR></P>

<H4><A ID="I55" NAME="I55">

<FONT SIZE=3><B>MUF Programming</B>

<BR></FONT></A></H4>

<P>In order to program more complex objects in MUCK, you have to learn how to program in the MUCK programming language, called Multi-User Forth, or MUF for short.

<BR></P>

<H4><A ID="I56" NAME="I56">

<FONT SIZE=3><B>Using the MUF Editor and Compiler</B>

<BR></FONT></A></H4>

<P>MUF programs must be entered into the MUCK and then compiled in order for them to function. To enter the editor, you can type:

<BR></P>

<PRE>@program <I>program-name</I></PRE>

<P>This will put you into the MUCK editor. You can then enter insert mode by typing

<BR></P>

<PRE><I>line-number</I> i</PRE>

<P>which will start inserting what you type before the given <I>line-number</I>. To exit insert mode, type a period (.) on a line by itself.

<BR></P>

<P>You can then compile the program by typing:

<BR></P>

<PRE>c</PRE>

<P>And, finally, you can run the program by typing:

<BR></P>

<PRE>????</PRE>

<P>A more detailed listing of editor commands can be found in the MUCK Reference Manual section, later in this chapter. This should be enough to get you started.

<BR></P>

<H4><A ID="I57" NAME="I57">

<FONT SIZE=3><B>MUF Basics</B>

<BR></FONT></A></H4>

<P>In MUF programs, comments are enclosed in parentheses:

<BR></P>

<PRE>(This is a comment)</PRE>

<P>MUF programs consist of <I>words</I>. A word is simply a series of statements. They usually manipulate the stack in some manner. A word begins with a semicolon, followed by the name of the word, the statements of the word, and then ending with a 
semicolon:

<BR></P>

<PRE>: <I>word-name</I>

   <I>statements</I>

;</PRE>

<P>There are three basic types of values in MUF: the integer, the string, and the DBREF. Strings are enclosed in double-quotes. DBREFs are denoted by putting a pound symbol (#) in front of the DBREF number:

<BR></P>

<PRE>7        (This is an integer)

&quot;Test&quot;   (This is a string)

#354     (This is a DBREF)</PRE>

<P>MUF is a stack-based programming language based on Forth. If you are not familiar with the concept of a stack, it is a place to hold information, and it has a &quot;top&quot; element that can be accessed as necessary. When you &quot;push&quot; an 
element onto the stack, that element becomes the new &quot;top&quot; of the stack, similar to stacking plates on top of one another. The first element to be removed, or &quot;popped&quot; from the stack is the top element. The next element to be removed is 
the element under the top element, and so forth.

<BR></P>

<P>You can put these basic values onto the stack by simply specifying them in your MUF words:

<BR></P>

<PRE>: stack_test

     56

     &quot;First string&quot;

     #45

     &quot;Second string&quot;

;</PRE>

<P>In this example, the stack now has four values on it. The number 56 is at the bottom of the stack because it was pushed onto the stack first. The Second string is on the top of the stack, and we can access it if we look at the top of the stack or pop 
the top value from the stack.

<BR></P>

<P>The indentation did not matter in the previous example. Indentation is simply used to make MUF programs easier to read. The previous example can also be written:

<BR></P>

<PRE>: stack_test

     56 &quot;First string&quot; #45 &quot;Second string&quot;

;</PRE>

<H4><A ID="I58" NAME="I58">

<FONT SIZE=3><B>Basic MUF Functions</B>

<BR></FONT></A></H4>

<P>MUF functions operate on the top of the stack. A value may be taken from the top of the stack, processed in some manner, and perhaps put back onto the stack. More commonly, the top two values are taken from the top of the stack and then processed in 
some manner to result in one new value, which is then placed back onto the top of the stack. The addition function behaves in this manner. It takes the top two values from the stack, adds them together, and then places the result back onto the stack:

<BR></P>

<PRE>: simple_add

     5 8 +

;</PRE>

<P>This simple addition would first place 5 onto the stack, followed by 8. The + operator would then pop these two values off the stack, add them together, and push the result, 13, back onto the stack. The number 13 could then be used in some fashion.

<BR></P>

<HR ALIGN=CENTER>

<NOTE>

<IMG SRC="note.gif"><B>Note:</B> This is the same as RPN (Reverse Polish Notation), also known as <I>postfix</I>. Anyone familiar with the high-end HP calculators will know how to use it already.

<BR></NOTE>

<HR ALIGN=CENTER>

<P>Another example is

<BR></P>

<PRE>: more_add

     4 5 9 + 8 + +

;</PRE>

<P>which first puts 4, 5 and 9 on the stack. It then adds the top two values, 5 and 9, and pushed their sum, 14, back onto the stack. It then pushes 8 onto the stack. The next addition adds 14 and 8 together to get 22, and the last addition adds 4 and 22 
together to get 26. Thus, at the end, the stack has one value: 26.

<BR></P>

<P>Subtraction, multiplication and division work in a similar manner. For subtraction, the top value is subtracted from the value underneath it. For division, the second-from-the-top value is divided by the top value.

<BR></P>

<P>The equality function is an equals sign (=). It pops the top two integers from the stack and compares them. If they are equal, 1 is pushed onto the stack. If they are not equal, 0 is pushed onto the stack. Thus:

<BR></P>

<PRE>: equals_test

     4  100  =  7  7  =

;</PRE>

<P>would result in a stack of: 0 1.

<BR></P>

<P>Similar to the equality function, the dbcmp function also compares two values on the top of the stack. It compares two DBREFs. If they are equal, 1 is pushed, otherwise 0 is pushed.

<BR></P>

<PRE>: dbcmp_example

     #54  #54  dbcmp

;</PRE>

<P>would result in the stack consisting of the number 1.

<BR></P>

<P>As mentioned previously, the top value can be removed from the stack by &quot;popping&quot; it. The pop function accomplishes this in MUF programs, appropriately enough:

<BR></P>

<PRE>: pop_example

     5 7 pop 8 9 pop

;</PRE>

<P>This places 5 and 7 onto the stack, pops 7 back off, then places 8 and 9 onto the stack and pops 9 back off. The stack would thus be 5, 8, with 8 being the top of the stack.

<BR></P>

<P>Another basic function is the swap function. It switches the top two values on the stack around:

<BR></P>

<PRE>: swap_example

     4 5 swap 7 swap

;</PRE>

<P>This program would place 4 and 5 onto the stack, then swap them to get 5 and 4. The number 7 is then pushed onto the stack, to get 5, 4 and 7. The last swap would swap 4 and 7. The end result is 5, 7, 4, with 4 being at the top of the stack.

<BR></P>

<P>One more frequently used function is the duplicate function, dup. It simply pushes a copy of the top of the stack onto the stack:

<BR></P>

<PRE>: duplicate_example

     4 dup 7 dup

;</PRE>

<P>After this function, the stack would be 4, 4, 7, 7. The second 7 would be on the top of the stack.

<BR></P>

<H4><A ID="I59" NAME="I59">

<FONT SIZE=3><B>Variables</B>

<BR></FONT></A></H4>

<P>You can use variables in MUF code. First, you must declare the variable by putting:

<BR></P>

<PRE>var <I>variable-name</I></PRE>

<P>at the top of the program. Once declared, the variable can be used in a variety of ways.

<BR></P>

<P>The variable storage function is an exclamation point (!). It places the next-to-the-top value into the variable named on the top of the stack.

<BR></P>

<PRE>var testvar

: variable_storage_example

     7 testvar !

;</PRE>

<P>This puts the value 7 into the variable named testvar.

<BR></P>

<P>To retrieve the value of a variable, use the fetch function, which is an &quot;at&quot; symbol (@). It pops the top value on the stack and uses it as a variable name. The contents of that variable are then placed back onto the stack:

<BR></P>

<PRE>var testvar

: variable_fetch_example

     7 testvar !

     testvar @

;</PRE>

<P>This first places the value 7 into the variable named testvar. It then accesses testvar and places its contents, 7, onto the stack. The stack, then, would consist only of the number 7.

<BR></P>

<P>Three special variables in MUF are me, loc, and trigger. The me variable contains the DBREF of the playerm, and loc contains the DBREF of the player's current room. The trigger variable contains the DBREF of the player who triggered the program. These 
variables will be used in later examples.

<BR></P>

<H4><A ID="I60" NAME="I60">

<FONT SIZE=3><B>Messages</B>

<BR></FONT></A></H4>

<P>To send a message to an object, you use the notify function. This function sends the string at the top of the stack to the player at the second top element of the stack:

<BR></P>

<PRE>: notify_example

     me  @  &quot;Hello, there!&quot;  notify

;</PRE>

<P>This example first retrieves your DBREF from the me variable. It then pushes a string onto the stack. Finally, it uses the notify function to send that string to you.

<BR></P>

<H4><A ID="I61" NAME="I61">

<FONT SIZE=3><B>Conditional Statements</B>

<BR></FONT></A></H4>

<P>MUF has an IF-THEN construct similar to other programming languages. However, it has a major difference with the IF-THEN statement you may be familiar with from other programming languages. In MUF, the IF-THEN statement is more like a compare and jump 
statement in assembly language.

<BR></P>

<PRE>if

     <I>if-statements</I>

then

<I>following-statements</I></PRE>

<P>In the preceding syntax, the if keyword pops the top value from the stack. If the value does not equal 0, the <I>if-statements</I> are executed, and then the <I>following-statements</I> are <I>also</I> executed. The <I>if-statements</I> consist of all 
statements up to the next then keyword. If the value popped by if is 0, the <I>if-statements</I> are skipped, and only the <I>following-statements</I> are executed.

<BR></P>

<P>As an example, consider:

<BR></P>

<PRE>: if_example

     4 2 2 +  =

     if &quot;The values were equal&quot;

     then &quot;Top string&quot;

;</PRE>

<P>First, 4 and the sum of 2 and 2 are compared, using the equality function. Since they are equal, the if statement pushes The values are equal onto the stack. It then pushes the string Top string onto the top of the stack.

<BR></P>

<P>The program

<BR></P>

<PRE>: if_example

     4 2 3 +  =

     if &quot;The values were equal&quot;

     then &quot;Top string&quot;

;</PRE>

<P>would only push the string Top string onto the stack because 4 and 5 are not equal.

<BR></P>

<P>As a helpful hint, it may be useful to think of the then keyword as an endif.

<BR></P>

<H4><A ID="I62" NAME="I62">

<FONT SIZE=3><B>An Example MUF Program</B>

<BR></FONT></A></H4>

<P>With these concepts, you can create many MUF programs. In addition, you can use the built-in functions that are available in MUF. For a listing of these, consult the MUCK Reference Manual, later in this chapter.

<BR></P>

<H3><A ID="I63" NAME="I63">

<FONT SIZE=4><B>Programming a MUSH</B>

<BR></FONT></A></H3>

<P>MUSH, which stands for Multi-User Shared Hallucination, is a spin-off of the original TinyMUD. This section describes TinyMUSH version 2.0.

<BR></P>

<H4><A ID="I64" NAME="I64">

<FONT SIZE=3><B>Popular MUSHes</B>

<BR></FONT></A></H4>

<P>There are several MUSHes on the Internet. Many of them have certain themes.

<BR></P>

<TABLE BORDER>

<TR>

<TD>

<P><B>Name</B></P>

<TD>

<P><B>Machine Name</B></P>

<TD>

<P><B>Internet Address</B></P>

<TD>

<P><B>Port</B></P>

<TR>

<TD>

<P>Deep Seas</P>

<TD>

<P>muds.okstate.edu</P>

<TD>

<P>139.78.9.1</P>

<TD>

<P>6250</P>

<TR>

<TD>

<P>DuneMUSH</P>

<TD>

<P>mellers1.berkeley.edu</P>

<TD>

<P>128.32.243.78</P>

<TD>

<P>4201</P>

<TR>

<TD>

<P>NarniaMush</P>

<TD>

<P>argo.unm.edu</P>

<TD>

<P>129.24.9.24</P>

<TD>

<P>6250</P>

<TR>

<TD>

<P>NeverendingStory</P>

<TD>

<P>jove.cs.pdx.edu</P>

<TD>

<P>131.252.21.12</P>

<TD>

<P>9999</P>

<TR>

<TD>

<P>PernMUSH</P>

<TD>

<P>cesium.clock.org</P>

<TD>

<P>130.43.2.43</P>

<TD>

<P>4201</P>

<TR>

<TD>

<P>Shadowrun</P>

<TD>

<P>yacht.slip.andrew.cmu.edu</P>

<TD>

<P>128.2.116.75</P>

<TD>

<P>4201</P>

<TR>

<TD>

<P>TinyCWRU</P>

<TD>

<P>caisr2.caisr.cwru.edu</P>

<TD>

<P>129.22.24.22</P>

<TD>

<P>4201</P></TABLE>

<P>DeepSeas, previously known as SpaceMadness, DreamScape, Asylum, Chaos, and TinyHELL, is another long-standing mud with a consistent player base. A lot of dino mudders (long-timers) can be found there.

<BR></P>

<P>These addresses are current as of August, 1994. Keep in mind that they may change.

<BR></P>

<H3><A ID="I65" NAME="I65">

<FONT SIZE=4><B>Things Specific to MUSHes</B>

<BR></FONT></A></H3>

<P>In addition to the commands and objects previously mentioned in the tutorial section, there are a few things that are specific to MUSHes.

<BR></P>

<H4><A ID="I66" NAME="I66">

<FONT SIZE=3><B>Possessive Pose</B>

<BR></FONT></A></H4>

<P>You can use a semicolon to possessive-pose. This is the same as posing (acting), except that it adds a possessive <I>s</I> after your character name and before the action message

<BR></P>

<PRE>;<I>message</I>

&gt; ;brain hurts.

Speedy's brain hurts.</PRE>

<H4><A ID="I67" NAME="I67">

<FONT SIZE=3><B>Puppets</B>

<BR></FONT></A></H4>

<P>Puppets are special types of objects that seem just like players. Puppets can be controlled by their owners and can see and hear things in a room just like a player would. The controlling player can then use the information returned by the puppet 
because the puppet echoes the text it sees and hears back to its owner. It does not echo back actions that are performed in the same room as its owner, to prevent message confusion.

<BR></P>

<P>To change an object into a puppet, set the object to be a puppet: @set <I>object</I> = puppet. The puppet will announce that it has grown ears and can now hear. After it becomes a puppet, you can use its name or its DBREF to have it perform actions that 
you want.

<BR></P>

<P>You can force an object to perform some action by using @force <I>object</I> = <I>actions</I>. Or, you can use <I>DBREF</I> <I>actions</I>. The object will behave as if it, itself, had typed the action.

<BR></P>

<PRE>&gt; @create a little dog

a little dog created as object #333

&gt; @set little dog = puppet

a little dog grows ears and can now hear.

Set.

&gt; inventory

You are carrying:

a little dog (#333p)

You have 930 credits.

&gt; @desc little dog = You see a little puppy.

Set.

&gt; drop little dog

a little dog&gt; Speedy's Room

a little dog&gt; You are in Speedy's Room.

a little dog&gt; Contents:

a little dog&gt; Speedy (#5Pc)

a little dog&gt; Obvious exits:

a little dog&gt; north

a little dog&gt; Dropped.

Dropped.

&gt; l little dog

a little dog (#333p)

You see a little puppy.

&gt; @force little dog = :wags its tail.

a little dog wags its tail.

&gt; #333 :pants happily.

a little dog pants happily.

&gt; #333 &quot;Yap yap!

a little dog&gt; You say &quot;Yap yap!&quot;

a little dog says &quot;Yap yap!&quot;

&gt; #333 north

a little dog walks north out of Speedy's Room.

a little dog has left.

a little dog&gt; Hallway

a little dog&gt; You are in a short hallway. Speedy's room is to the south. A stairway can be seen to the north.

a little dog&gt; Obvious exits:

a little dog&gt; north south

&gt; #333 south

a little dog&gt; You walk south into Speedy's Room

a little dog&gt; Speedy's Room

a little dog&gt; You are in Speedy's Room.

a little dog&gt; Contents:

a little dog&gt; Speedy (#5Pc)

a little dog&gt; Obvious exits:

a little dog&gt; north

a little dog walks in from the north.

a little dog has arrived.

&gt; @set #333 = DESTROY_OK

Set.

&gt; @destroy #333

a little dog&gt; *NOTHING*

You get back your 10 credit deposit for a little dog (#333).

Destroyed.</PRE>

<H4><A ID="I68" NAME="I68">

<FONT SIZE=3><B>Listening and Responding to Messages</B>

<BR></FONT></A></H4>

<P>Sometimes it's fun to program an object that listens for certain strings and responds to those strings in some manner. The @listen directive will set the pattern string and the @ahear attribute sets the actions that are executed when the listen string 
is matched.

<BR></P>

<PRE>&gt; @listen <I>object</I> = <I>string</I>

&gt; @ahear <I>object</I> = <I>actions</I></PRE>

<P>When using @listen, the string frequently has some word or phrase that the object is listening for, plus some wildcard characters to match whatever else might be in a message. If a matching string is seen, the @ahear actions are then executed. For 
instance, the command

<BR></P>

<PRE>&gt; @listen me = * movie*</PRE>

<P>would be looking for a string of anything, followed by a space, followed by the word movie, followed by anything else. This could match something like Speedy went to see a movie today. It could also match What's playing at the movies tonight?.

<BR></P>

<PRE>&gt; @listen me = * movie*

Speedy - Set.

&gt; @ahear me = :wanna direct!

Speedy - Set.</PRE>

<P>Then, later, maybe someone mentions movies. That triggers the response automatically:

<BR></P>

<PRE>Archimedes went to see a movie last night.

Speedy wanna direct!

Mak says, &quot;Which movie did you see?&quot;

Speedy wanna direct!</PRE>

<P>In addition to the @ahear attribute, there is also an @amhear and an @aahear attribute. @ahear responds only to messages that the listening object did not generate. @amhear only responds to messages that the object itself generated. @aahear responds to 
all messages.

<BR></P>

<H4><A ID="I69" NAME="I69">

<FONT SIZE=3><B>Percent Substitutions</B>

<BR></FONT></A></H4>

<P>Whenever an action occurs, the mud stores information related to that action in a special storage area. These variables can then be accessed using percent substitutions.

<BR></P>

<P>Percent substitutions are simply variables that begin with a percent sign. For instance, in the previous section, you learned about pronoun substitutions. Pronoun substitutions are just special kinds of percent substitutions.

<BR></P>

<P>One of the items that the mud stores is the name of the <I>enactor</I>&#151;the object that caused an action. As described in the previous section, the name of the enactor is stored in the %N variable. The %N variable is the capitalized name, such as 
Speedy, and the %n variable is the uncapitalized form, such as speedy. Additionally, the actual DBREF of the enactor can be accessing by using the %# variable.

<BR></P>

<P>Another item stored by the mud is the <I>affected object</I>&#151;the object on which the action is being performed. The DBREF of this object can be accessed by using the %! variable.

<BR></P>

<P>For example, if Speedy dropped a bowling ball, Speedy would be the enactor, and the bowling ball would be the affected object. Speedy's name could be accessed using %N or %n, and Speedy's DBREF could be accessed using %#. The DBREF of the bowling ball 
could be accessed using %!.

<BR></P>

<P>The DBREF of the location of the action can be accessed through the %l variable.

<BR></P>

<P>There are several special percent substitutions that are used for text formatting. These formatting characters resemble the special formatting characters in the C programming language: %r converts into a carriage return-newline combination, %t converts 
into a tab character, %b converts into a blank space, and %% converts into an actual percent sign.

<BR></P>

<P>That is why you have to type <I>two</I> percent signs when you want to say a line with a percent sign in it. If you say

<BR></P>

<PRE>&gt; &quot;24.6% of all statistics are made up on the spot!

Speedy says &quot;24.6 of all statistics are made up on the spot!&quot;</PRE>

<P>you notice that the percent sign disappears. The mud is trying to convert it to a percent substitution, and a percent sign followed by a blank space converts into a blank. To get a percent sign into your text and actions, type <I>two</I> percent signs

<BR></P>

<PRE>&gt; &quot;24.6%% of all statistics are made up on the spot!

Speedy says &quot;24.6% of all statistics are made up on the spot!&quot;</PRE>

<P>since the %% is the formatting specification for a percent sign.

<BR></P>

<P>Another way to get an actual percent sign is to use the escape character, which is a backslash (\):

<BR></P>

<PRE>&gt; &quot;24.6\% of all statistics are made up on the spot!

Speedy says &quot;24.6% of all statistics are made up on the spot!&quot;</PRE>

<P>The escape character causes any of the characters following it to be printed as-is.

<BR></P>

<H4><A ID="I70" NAME="I70">

<FONT SIZE=3><B>Registers</B>

<BR></FONT></A></H4>

<P>In addition to the various percent substitutions just mentioned, there are 26 registers that you can set using @va through @vz and access by using %va through %vz. These registers are like attributes or variables. They can store just about any mud 
value&#151;numbers, strings, messages, function results, and so forth. To set a register, use the syntax

<BR></P>

<PRE>&gt; @<I>register</I> <I>object</I> = <I>actions</I></PRE>

<P>and then access it using the corresponding percent-substitution, %<I>register</I>.

<BR></P>

<P>As an example, consider creating a water balloon that splats when it is dropped. The va register will be used to print out a message when the balloon is dropped.

<BR></P>

<PRE>&gt; @create water balloon

water balloon created as object #1765.

&gt; @va water balloon = SPLAT!

Set.

&gt; @drop water balloon = The balloon falls and goes %va.

Set

&gt; drop water balloon

The balloon falls and goes SPLAT!</PRE>

<H4><A ID="I71" NAME="I71">

<FONT SIZE=3><B>Triggers</B>

<BR></FONT></A></H4>

<P>You can also use the register to perform an action. To do this, you have to <I>trigger</I> the register using the trigger command:

<BR></P>

<PRE>&gt; @trigger <I>object</I>/<I>attribute</I></PRE>

<P>The @trigger command can be abbreviated @tr.

<BR></P>

<P>In the water balloon example, a more realistic action would be for the water balloon to destroy itself when it is dropped. You can put the destroy command in a register, and then trigger it using the trigger command when the balloon is dropped. So, 
adding to the water balloon example:

<BR></P>

<PRE>&gt; @vb water balloon = @destroy me

Set.

&gt; @adrop water balloon = @tr me/vb

Set.

&gt; drop water balloon

The balloon falls and goes SPLAT!

water balloon has left.

You get back your 10 credit deposit for water balloon (#1765).</PRE>

<P>When the balloon is dropped, the @drop attribute used the va register as a string, and the @adrop attribute triggered the vb register, which destroyed the balloon.

<BR></P>

<P>With 26 registers to play around with, you can perform a lot of complex programming. You can use registers to store temporary information. Registers can trigger other registers, too.

<BR></P>

<H4><A ID="I72" NAME="I72">

<FONT SIZE=3><B>Numbered Variables</B>

<BR></FONT></A></H4>

<P>You can also make use of the 10 numbered variables, named %0 through %9. These variables are collectively known as the <I>stack</I> in mud terms, although it isn't really a stack in the computer science sense of pushing and popping objects. The stack is 
just a storage area for the 10 numbered variables.

<BR></P>

<P>These numbered variables are known as <I>positional parameters</I>. They are set consecutively using two methods: the @listen command and the @trigger command.

<BR></P>

<P>To illustrate the @listen command and how positional parameters are set, consider a parrot that listens for phrases with the word <I>Parrot</I> in them. The parrot will speak the three phrases that come after the trigger word Parrot:

<BR></P>

<PRE>&gt; @create parrot

parrot created as object #1799.

&gt; @listen parrot = * says &quot;Parrot * * * *

parrot - set.

Set.

&gt; @ahear parrot = &quot;SQUAWK %1 %2 %3

Set.

&gt; drop parrot

Dropped.

&gt; &quot;Parrot can you hear?

You say &quot;Parrot can you hear me?&quot;

parrot says &quot;SQUAWK can you hear&quot;

&gt; &quot;Parrot tell a story to us.

You say &quot;Parrot tell a story to us.&quot;

parrot says &quot;SQUAWK tell a story&quot;</PRE>

<P>In this simple example, the asterisks in the @listen command convert to numbered variables %0, %1, %2, %3, and %4. The first asterisk matches the player's name from the spoken text, and this is placed in the variable %0. The three phrases after the 
string Parrot are matched and placed into numbered variables %1, %2, %3, and %4, respectively. The %1 variable is the first word after Parrot, %2 is the second word, %3 is the third word, and %4 is everything else, including the ending double-quote. The 
@ahear command then uses some of these variables in its spoken text.

<BR></P>

<P>The @trigger command can also be used to set the numbered variables, using the format:

<BR></P>

<PRE>&gt; @trigger object/attribute = item, item, item, ...</PRE>

<P>This command sets the positional parameters to the given items, consecutively, starting from %0. The attribute that is triggered can then access these numeric variables.

<BR></P>

<P>Consider a globe that has its va attribute programmed as follows:

<BR></P>

<PRE>&gt; @va globe = @emit The globe %0, %1, and %2.

Set.</PRE>

<P>Now, to get %0, %1, and %2 to be shimmers, sparkles, and glows eerily, you can use the @trigger command:

<BR></P>

<PRE>&gt; @tr globe/va = shimmers, sparkles, glows eerily.

Triggered.

The globe shimmers, sparkles, and glows eerily.</PRE>

<P>Note how the parameters to the @trigger command become the numeric variables for the va attribute.

<BR></P>

<H4><A ID="I73" NAME="I73">

<FONT SIZE=3><B>Braces</B>

<BR></FONT></A></H4>

<P>You can use <I>braces</I> to surround strings so that commas within them do not get interpreted by the mud as separation characters.

<BR></P>

<P>Consider the globe in the previous section. What if you wanted the second phrase to be hums, glistens instead of sparkles? If you type

<BR></P>

<PRE>&gt; @tr globe/va = shimmers, hums, glistens, glows eerily.</PRE>

<P>you get

<BR></P>

<PRE>Triggered.

The globe shimmers, hums, and glistens.</PRE>

<P>This is because the comma separating hums and glistens is taken to be a parameter separator.

<BR></P>

<P>In cases like this, you want a comma to be taken as an actual comma, rather than a parameter separator. You can use braces to specify that the string within the braces is to be taken as a whole unit, and any commas within the braces are part of the 
string:

<BR></P>

<PRE>&gt; @tr globe/va = shimmers, {hums, glistens}, glows eerily.

Triggered.

The globe shimmers, hums, glistens, and glows eerily.</PRE>

<P>So remember, when you want to get an actual comma into a string, you may need to throw a pair of braces around the string. Braces are also frequently used in function calls and switch statements (both discussed later in this section), since those 
programming constructs commonly use commas.

<BR></P>

<H4><A ID="I74" NAME="I74">

<FONT SIZE=3><B>Using an Object</B>

<BR></FONT></A></H4>

<P>You can also trigger an object by <I>using</I> it. To use an object, simply type the use command:

<BR></P>

<PRE>&gt; use <I>object</I></PRE>

<P>This command triggers the @use, @ouse, and @ause attributes. The object will respond to the use command only if the @ause attribute has been set on the object.

<BR></P>

<H4><A ID="I75" NAME="I75">

<FONT SIZE=3><B>Functions</B>

<BR></FONT></A></H4>

<P>The format for a function call is:

<BR></P>

<PRE>[ <I>function-name</I>(<I>parameters...</I>) ]</PRE>

<P>The parameters of the function must be enclosed within parentheses, and the function itself must be enclosed in square brackets.

<BR></P>

<P>As an example, the name() function returns the name of an object when given its DBREF. If object #5 was the player Speedy, you could determine the name by using the name() function and the object number:

<BR></P>

<PRE>&gt; @emit [name(#5)]

Speedy</PRE>

<P>Functions can be nested, and nested functions only require one outermost set of square brackets. You can put the name() function, mentioned earlier, and the Ustrlen() function, which returns the length of a string, together to find out the length of the 
name of object #5 by typing:

<BR></P>

<PRE>&gt; @emit [strlen(name(#5))]

6</PRE>

<P>Sometimes, you may want to evaluate the value of an attribute as though it were a function. In those cases, you may have to add additional square brackets to denote that you are trying to access a variable as a function.

<BR></P>

<P>For instance, the get(object/attribute) function returns the value of the named attribute on a given object. If the va and vb attributes on some test object are defined as

<BR></P>

<PRE>&gt; @va testobject = vb

Set.

&gt; @vb testobject = blah blah

Set.</PRE>

<P>then by accessing va you see

<BR></P>

<PRE>&gt; @emit [get(testobject/va)]

vb</PRE>

<P>and by accessing vb indirectly through va you see

<BR></P>

<PRE>&gt; @emit [get(testobject/[get(testobject/va)])]

blah blah</PRE>

<P>because [get(testobject/va)] returns vb, which is substituted into the outermost get()function to return blah blah.

<BR></P>

<P>There are dozens of predefined functions to choose from. A few important functions are discussed next. For a description of the rest of the functions available, or for quick reference, see the function glossary section, later in this chapter

<BR></P>

<H4><A ID="I76" NAME="I76">

<FONT SIZE=3><B>The </B><B><I>v()</I></B><B> Function</B>

<BR></FONT></A></H4>

<P>The v() function is simply another way to access the 26 v-registers. The code [v(va)] is functionally equivalent to %va. However, the percent sign form is evaluated faster than the function call form, so it tends to be used in most cases.

<BR></P>

<H4><A ID="I77" NAME="I77">

<FONT SIZE=3><B>The </B><B><I>s()</I></B><B> Function</B>

<BR></FONT></A></H4>

<P>The s() function performs pronoun substitution on a string, and returns that string. The pronouns apply to the object that triggers the function.

<BR></P>

<P>Thus, if your character has male gender, and you evaluate

<BR></P>

<PRE>&gt; @emit [s(%P went down the road.)]</PRE>

<P>you see

<BR></P>

<PRE>He went down the road.</PRE>

<P>And, if your character had female gender, you would see:

<BR></P>

<PRE>She went down the road.</PRE>

<P>All the pronoun substitutions, discussed earlier, can be used in the s() function.

<BR></P>

<H4><A ID="I78" NAME="I78">

<FONT SIZE=3><B>The </B><B><I>get()</I></B><B> Function</B>

<BR></FONT></A></H4>

<P>The get() function, mentioned earlier, is another frequently used function. It is used to access various attributes from a particular object. Its syntax is

<BR></P>

<PRE>[get(object/attribute)]</PRE>

<H4><A ID="I79" NAME="I79">

<FONT SIZE=3><B>The </B><B>rand()</B><B> Function</B>

<BR></FONT></A></H4>

<P>This function tends to be used frequently. The syntax is

<BR></P>

<PRE>rand(<I>number</I>)</PRE>

<P>and it returns a random integer between 0 and (number - 1).

<BR></P>

<H4><A ID="I80" NAME="I80">

<FONT SIZE=3><B>The Switch Command</B>

<BR></FONT></A></H4>

<P>You can create conditional expressions on an object by using the switch command. The switch command is similar to a CASE statement in a programming language. There is a conditional expression that is evaluated and, based on the results of that 
evaluation, different actions are performed.

<BR></P>

<P>The format for the switch command is:

<BR></P>

<PRE>&gt; @switch test = condition1, action1, condition2, action2, ..., conditionN, actionN, default</PRE>

<P>The switch command tests the result of the <I>test</I> against each <I>condition</I>. If there is a match, the corresponding <I>action</I> is performed.

<BR></P>

<P>As an example, consider programming a dog to obey commands you give it. When you tell the dog to sit, it sits down; when you tell the dog to speak, it barks, and so forth. You can accomplish this by using the switch command. First, set up the dog to 
listen for commands:

<BR></P>

<PRE>&gt; @create Rover

Rover created as object #6745.

&gt; @listen Rover = *&quot;Rover, *&quot;

Set.</PRE>

<P>Now, use the switch command on the @ahear attribute to perform different actions based on what a player commands Rover to do:

<BR></P>

<PRE>&gt; @ahear Rover = @switch %1 = sit , :sits down. , speak , &quot;RARWK!, jump, :does a backflip., play dead, :lies down on the ground., beg, {:whimpers, cries, and looks utterly heartbroken.}

Set.</PRE>

<P>Now you can tell Rover what to do:

<BR></P>

<PRE>&gt; drop Rover

Dropped.

&gt; &quot;Rover, sit

You say &quot;Rover, sit&quot;

Rover sits down.

&gt; &quot;Rover, speak

You say, &quot;Rover, speak&quot;

Rover says &quot;RARWK!&quot;

&gt; &quot;Rover, jump

You say &quot;Rover, jump&quot;

Rover does a backflip.

&gt; &quot;Rover, play dead

You say &quot;Rover, play dead&quot;

Rover lies down on the ground.

&gt; &quot;Rover, beg

You say &quot;Rover, beg&quot;

Rover whimpers, cries, and looks utterly heartbroken.</PRE>

<P>Note that the conditions and actions are separated by commas. As mentioned previously, if you want to use a comma or a semicolon in one of your conditions or actions, make sure you surround the statement with braces ({}). Otherwise, a comma signifies a 
new condition or action, and a semicolon signifies the end of the switch command.

<BR></P>

<P>The last action in the switch command for Rover is enclosed in braces because the action contains commas within it.

<BR></P>

<P>As another example, you can achieve an IF-THEN-ELSE effect by using a switch statement and testing for either 1 or 0 in the conditionals:

<BR></P>

<PRE>&gt; @create Parrot

Parrot created as object #6746.

&gt; @listen Parrot = * has arrived.

Set.

&gt; @ahear Parrot = @switch [eq(&quot;Speedy&quot;, %0)] = 1, {:flies around squawking, &quot;Speedy is here! Speedy is here!&quot;}, 0, :ignores %0.</PRE>

<P>The test portion of the switch command tests to see if Speedy is the name of the player who is entering the room. If so, it flies around and announces Speedy's entrance; if not, it ignores the entering player:

<BR></P>

<PRE>Snowball has arrived.

Parrot ignores Snowball.

Speedy has arrived.

Parrot flies around squawking, &quot;Speedy is here! Speedy is here!&quot;

Pooka has arrived.

Parrot ignores Pooka.</PRE>

<P>Again, note the braces around the true part of the command because of the comma within it.

<BR></P>

<H4><A ID="I81" NAME="I81">

<FONT SIZE=3><B>User-Defined Commands</B>

<BR></FONT></A></H4>

<P>Perhaps you want to create an object and then define some specialized commands on that object. You can create a stuffed bear that growls when you squeeze it. The squeeze command is not a predefined command in the mud. You have to define it. You can 
create user-defined commands by setting them on a register:

<BR></P>

<PRE>&gt; @attribute object = $command:actions</PRE>

<P>To define the squeeze command on the bear:

<BR></P>

<PRE>&gt; @va bear = $squeeze:@emit The stuffed bear grrrowls huskily.</PRE>

<P>Then, when you type

<BR></P>

<PRE>&gt; squeeze</PRE>

<P>you see

<BR></P>

<PRE>The stuffed bear grrrowls huskily.</PRE>

<P>You can define multiple commands on an object. Just make sure that you don't pick a command name that is already used, such as page or get, because predefined mud commands take precedence over user-defined commands.

<BR></P>

<P>You can allow your user-defined commands to accept arguments, too. You specify these arguments by using asterisks (*) in the command definition. These asterisks are converted into the positional parameters for the attribute that defines the command. For 
instance, you can change the squeeze command to accept an argument:

<BR></P>

<PRE>&gt; @va bear = $squeeze *:@emit You squeeze the bear's %0. The bear grrrowls huskily.

Set.

&gt; squeeze tummy

You squeeze the bear's tummy. The bear grrrowls huskily.</PRE>

<H4><A ID="I82" NAME="I82">

<FONT SIZE=3><B>User-Defined Attributes</B>

<BR></FONT></A></H4>

<P>In addition to user-defined commands on an object, you can also create user-defined attributes on an object. The format is:

<BR></P>

<PRE>&gt; &amp;attribute object = anything</PRE>

<P>You can also define an attribute using

<BR></P>

<PRE>&gt; @set object = attribute:anything</PRE>

<P>You can set an attribute on an object to anything you want. You can use it for temporary storage of variables, names or DBREFs of objects, strings, and so forth. You can define an unlimited number of attributes on an object.

<BR></P>

<P>Make sure that your user-defined attribute does not conflict with an already-defined attribute. As you create more and more complex objects, the chances increase for you to think of an attribute that you have already defined on that object, and you end 
up redefining something that you have already written!

<BR></P>

<P>You can access these attributes using the get() function or the v() function.

<BR></P>

<PRE>&gt; @va bear = $squeeze:@emit You squeeze the bear.;&amp;lastsqueeze bear = %N

Set.

&gt; @vb bear = $last:@emit This bear was last squeezed by [get(me/lastsqueeze)].

Set.

&gt; squeeze

You squeeze the bear.

&gt; last

This bear was last squeezed by Speedy.</PRE>

<P>This example sets a user-defined attribute called lastsqueeze whenever the bear is squeezed. The lastsqueeze attribute is set to the squeezing player's name. Then, when the player types last, this attribute is used to recall which player last squeezed 
the bear.

<BR></P>

<H4><A ID="I83" NAME="I83">

<FONT SIZE=3><B>The Queue</B>

<BR></FONT></A></H4>

<P>Each command that the mud executes goes into a queue first. The mud then runs commands out of the queue. Most of the time, the commands are executed immediately. However, some commands delay action for a few rounds, such as @trigger and @force.

<BR></P>

<P>To get a listing of the queue, you can use the @ps command. This command displays four queues. The Player Queue shows actions that you have triggered. The Object Queue shows actions that have been triggered by objects that you own. The Wait Queue 
displays commands that have been queued up and thus will be executed at some future point in time. And the Semaphore Queue shows semaphores, explained next. The @ps command has options you can use to obtain different process displays, such as a verbose 
listing, a brief listing, or a quick summary. See the Help on your mud for a description of these options to the @ps command.

<BR></P>

<H4><A ID="I84" NAME="I84">

<FONT SIZE=3><B>The Wait Command</B>

<BR></FONT></A></H4>

<P>You can delay commands so that they are executed at a later time by using the wait command:

<BR></P>

<PRE>&gt; @wait #seconds=actions</PRE>

<P>This queues up the specified actions and runs them after waiting the specified number of seconds. For instance, you can set up a twilight effect by setting up these attributes on a test object:

<BR></P>

<PRE>&gt; @va testobj = @wait 5 = @emit It is starting to get dark.;@tr me/vb

Set.

&gt; @vb testobj = @wait 10 = @emit It gets darker.;@tr me/vc

Set.

&gt; @vc testobj = @wait 15 = @emit It's completely dark now.

Set.</PRE>

<P>Then, if you trigger the va attribute, the messages are displayed after each wait delay:

<BR></P>

<PRE>&gt; @tr testobj/va</PRE>

<P>A delay of 5 seconds and you see:

<BR></P>

<PRE>It is starting to get dark.</PRE>

<P>Then, 10 seconds later:

<BR></P>

<PRE>It gets darker.</PRE>

<P>And, finally, 15 seconds after that:

<BR></P>

<PRE>It's completely dark now.</PRE>

<H4><A ID="I85" NAME="I85">

<FONT SIZE=3><B>The Halt Command</B>

<BR></FONT></A></H4>

<P>Sometimes, though, the commands that you have queued up will interact with each other in such a way that things get out of control. When these infinite loops occur, you can use the halt command to stop them.

<BR></P>

<PRE>&gt; @halt</PRE>

<P>clears out your personal queue,

<BR></P>

<PRE>&gt; @halt <I>command</I></PRE>

<P>clears out your queue and puts the specified command onto the queue, and

<BR></P>

<PRE>&gt; @halt object=command</PRE>

<P>clears out the given object's queue and puts the specified command onto the queue.

<BR></P>

<H4><A ID="I86" NAME="I86">

<FONT SIZE=3><B>Semaphores</B>

<BR></FONT></A></H4>

<P>One of the more advanced mud concepts is the <I>semaphore</I>. A semaphore is a signal that indicates that it is okay for something to perform some action. On many real-life train tracks, semaphores alongside the road indicate that a train has recently 
passed. The semaphore is initially green, indicating to an approaching train that it is okay for the train to continue. Once the train has passed, the semaphore changes to red. Another approaching train would see the red semaphore and know that another 
train recently passed through, and it may be necessary for the second train to slow or stop in order to avoid hitting the back end of the first train. A timer on the semaphore eventually changes the red light back to green.

<BR></P>

<P>Similarly, a semaphore in a mud is used to signal when certain actions can occur and prevent other actions from occurring until the correct time.

<BR></P>

<P>One typical use of a semaphore is to prevent an attribute or object from being triggered until it finishes executing its actions. For instance, you have a vending machine that dispenses magic baseballs. When it is triggered, it starts performing actions 
to create a new magic baseball and to give that baseball to you. A semaphore can be used to prevent someone from coming along and triggering the machine again while it is in the middle of first action list.

<BR></P>

<P>Another common use of semaphores is to force commands to be executed in a specific order. You can create user-defined commands hop, skip, and jump, and force them to be executed in that order through the use of semaphores.

<BR></P>

<P>Each semaphore has a <I>count</I> associated with it. The count is the number of actions that are currently blocked, waiting for a notification to unblock them and thus allow them to execute. If the count is 0, an action will occur immediately. A 
positive number indicates that that many actions are currently blocked. A negative number indicates that that many actions in a row will immediately execute.

<BR></P>

<P>The @wait command is used to place an action list on a semaphore and then &quot;block&quot; those actions from occurring until a notification occurs. The syntax is

<BR></P>

<PRE>&gt; @wait object=actions</PRE>

<P>which will set up a semaphore on the object and enqueue the given actions onto the semaphore's pending action list. If the actions are a list of commands, you have to enclose the list in braces. You can also set up a default execution time by using

<BR></P>

<PRE>&gt; @wait object/#seconds=actions</PRE>

<P>Such a wait command will behave like a normal wait command, except that after the given number of seconds, the actions execute anyway, regardless of whether an actual notification has occurred. You can use this to make sure a set of actions is 
eventually executed, even if no notification ever occurs.

<BR></P>

<P>The @notify command is used to notify the semaphore. When notified, the semaphore will execute the first action in the action list. The action item will be &quot;unblocked.&quot; A second notification will start the second action, and so forth. To 
notify a semaphore on an object, use

<BR></P>

<PRE>&gt; @notify <I>object</I></PRE>

<P>which will execute the first action that is pending on the object's semaphore queue. You can also execute a given number of actions by specifying that number

<BR></P>

<PRE>&gt; @notify object=#notifications</PRE>

<P>which executes that many actions on the object's semaphore queue.

<BR></P>

<P>Finally, the @drain command resets the semaphore count to 0.

<BR></P>

<P>Semaphores are usually used on larger, more complex objects, such as vending machines, mud e-mail systems, and so forth. As a simple example of semaphores, consider constructing a trick &quot;ack-in-the-box.&quot; The box contains a cat that springs out 
and coughs up a hairball when the box is wound up. The idea is for the commands relating to the hairball to be executed in a group, without interruption, so a semaphore is used:

<BR></P>

<PRE>&gt; @create ack-in-the-box

ack-in-the-box created as object #1515.

&gt; @desc ack= This is an ack-in-the-box. Type 'wind' to wind it up.

Set.</PRE>

<P>Now set up the ack-in-the-box to be ready to execute a wait command immediately by setting up a notification for right now, and for when the mud starts up. The startup actions make sure that the ack-in-the-box begins with its semaphore at -1, which 
means that any action on it will not be blocked.

<BR></P>

<PRE>&gt; @notify ack

Notified.

&gt; @startup ack=@drain me;@notify me

Set.</PRE>

<P>Now the object is ready to execute an action on it. This next section of code sets up a user-defined command, wind, that performs various actions and then, as its last action, renotifies the ack-in-the-box. This will allow the next wind command to 
immediately execute:

<BR></P>

<PRE>&gt; &amp;do_wind ack=$wind:@wait me={@emit The box whirrs and humms. Suddenly, the box SPROINGS open, and a scruffy-looking orange cat SPRINGS out of the box!;@create hairball;@desc hairball=You see a slimy cat hairball.;@drop hairball=The slimy cat 
hairball splats on the floor.;@adrop hairball=@emit A slimy cat hairball splats onto the floor.;@set hairball=DESTROY_OK;@emit The cat says &quot;ACK!&quot; and coughs up a hairball!;drop hairball;@emit The cat is then pulled back into the box, which 
closes.;@notify me}

Set.

And test it out!

&gt; drop ack-in-the-box

Dropped.

&gt; l

Speedy's Room

You are in Speedy's Room.

Contents:

ack-in-the-box (#1515)

Obvious exits:

out

&gt; l ack

This is an ack-in-the-box. Type 'wind' to wind it up.

&gt; wind

The box whirrs and humms. Suddenly, the box SPROINGS open, and a scruffy-looking orange cat SPRINGS out of the box!

The cat says &quot;ACK!&quot; and coughs up a hairball!

ack-in-the-box dropped hairball.

The cat is then pulled back into the box, which closes.

A slimy cat hairball splats onto the floor.

&gt; l

Speedy's Room

You are in Speedy's Room.

Contents:

hairball (#1530d)

ack-in-the-box (#1515)

Obvious exits:

out

&gt; wind

The box whirrs and humms. Suddenly, the box SPROINGS open, and a scruffy-looking orange cat SPRINGS out of the box!

The cat says &quot;ACK!&quot; and coughs up a hairball!

ack-in-the-box dropped hairball.

The cat is then pulled back into the box, which closes.

A slimy cat hairball splats onto the floor.

&gt; l

Speedy's Room

You are in Speedy's Room.

Contents:

hairball (#1530d)

hairball (#1531d)

ack-in-the-box (#1515)

Obvious exits:

out</PRE>

<P>As you can see, every time you wind the ack-in-the-box, a slimy hairball is created, which drops onto the floor! If you were holding the ack-in-the-box, it would drop into your hand (and thus into your inventory).

<BR></P>

<P>This simple example illustrates the use of semaphores to make sure that the commands to create the hairball describe it, and set attributes on it are not preempted by another wind command, issued as the ack-in-the-box was working on the first wind 
command.

<BR></P>

<H4><A ID="I87" NAME="I87">

<FONT SIZE=3><B>Putting It All Together: Exploding Jawbreaker Example</B>

<BR></FONT></A></H4>

<P>Putting all the concepts together, this section will go through the programming of an exploding jawbreaker. The jawbreaker will have a command defined on it that will allow a player to eat it. When the player attempts to eat the jawbreaker, various 
random amusing things happen. The object will also have several user-defined attributes. These attributes store various variables, strings, and messages.

<BR></P>

<P>Here goes!

<BR></P>

<PRE>&gt; @create jawbreaker

jawbreaker created as object #4545.

&gt; @desc jawbreaker = It looks like a giant candy jawbreaker, about the size of a plum. Upon closer inspection, it seems to be made of sugar, nitroglycerin, [name(v(currate))]'s saliva, salt and various corn by-products. Type 'eat jawbreaker' to eat it!

Set.

&gt; @fail jawbreaker = Type 'eat jawbreaker' to eat it.

Set.</PRE>

<P>This creates the jawbreaker and sets its description. Note the function call within the description. The currate attribute contains the DBREF of the player who last tried to eat the jawbreaker. This attribute is set by other commands later. The name() 
function uses the value in the currate attribute to generate the name of the player who last ate the jawbreaker.

<BR></P>

<PRE>&gt; &amp;comment jawbreaker = This is a trick jawbreaker that explodes when someone tries to eat it.

Set.</PRE>

<P>The comment attribute is simply a note to future programmers. It describes what this object does. On very complex objects, it is helpful to throw in a few comments to describe how the object works, so that other people can figure out what is going on!

<BR></P>

<P>Next, program the eat jawbreaker command:

<BR></P>

<PRE>&gt; &amp;chew jawbreaker = $eat jawbreaker:@emit [name(%#)] picks up the jawbreaker and pops it into %p mouth!;@trigger me/rand[rand(3)];&amp;lastate me=[get(me/currate)];&amp;currate me=%#

Set.</PRE>

<P>This sets the eat jawbreaker command and the actions to be performed when eat jawbreaker is typed by a player. There are four actions in the action list.

<BR></P>

<P>The first action displays a message to everyone indicating that the player put the jawbreaker in his or her mouth. Note how the %p pronoun substitution is used to print the appropriate possessive pronoun corresponding to the player.

<BR></P>

<P>The second action generates a random number from 0 to 2, using the rand() function. This number is appended to the string rand to generate a random attribute name, which is then triggered. One of three attributes will be triggered: rand0, rand1, or 
rand2.

<BR></P>

<P>The third and fourth actions in the action list set the lastate attribute to the last player who ate the jawbreaker, and the currate attribute to the player who is currently trying to eat the jawbreaker. These two attributes can then be used in later 
commands and actions.

<BR></P>

<P>Now, all there is to do is to define the three random actions that are triggered when the player eats the jawbreaker.

<BR></P>

<PRE>&gt; &amp;rand0 jawbreaker=@emit [name(v(currate))] closes [poss(v(currate))] eyes and smiles from ear to ear as the sugar kick from the jawbreaker sets in. Ahhh. After a few seconds of sucrose satisfaction, [name(v(currate))] removes the jawbreaker 
from [poss(v(currate))] mouth.</PRE>

<P>This first random action is fairly harmless. Nothing bad happens to the player. The currate attribute is used to determine both the player's name, using the name() function, and the possessive form of the player (his, her, its), using the poss() 
function.

<BR></P>

<PRE>&gt; &amp;rand1 jawbreaker=@emit [name(v(currate))]'s eyes get real big as the fire-hot super jalapeno pepper flavor of the jawbreaker takes effect! [poss(v(currate))]'s eyes start to water as [subj(v(currate))] screams, &quot;YOW THAT'S HOT!&quot; 
Suddenly, [name(v(currate))]'s head EXPLODES with a flash and a smell of hot peppers and burnt sugar!! *BOOM* !!;kill [name(v(currate))]=100</PRE>

<P>This second random action is a bit more violent. It kills off the player, due to the flavorful effects of the jawbreaker, by performing a kill command on that player. The subj() function returns the subjective pronoun of the player.

<BR></P>

<PRE>&gt;&amp;rand2 jawbreaker=@emit [name(v(currate))] gasps, &quot;I've been poisoned by [name(v(lastate))]'s *gag* spit!&quot; In a last-ditch attempt for revenge, [name(v(currate))] throws the jawbreaker at [name(v(lastate))]! [switch (eq(here, 
loc(v(lastate))), 1, The jawbreaker BONKs [name(v(lastate))] on the head and the unstable nitroglycerides in the jawbreaker EXPLODE!, 0, Luckily, [name(v(lastate))] is not around, and the jawbreaker merely ricochets off the wall and rolls to a stop 
nearby.)];kill [name(v(currate))]=100;kill [name(v(lastate))]=100</PRE>

<P>The last random action is somewhat whimsical. It tries to kill off both the current player and the player who last ate the jawbreaker. Note the switch statement in the action list. It tests to see if the player who last ate the jawbreaker is in the same 
room. If so, an appropriate message is printed as the jawbreaker hits that player. If not, the jawbreaker just rolls around to a stop. Finally, a few kill commands are performed. If the person who last ate the jawbreaker is not in the current room, that 
kill command will have no effect.

<BR></P>

<P>This exploding jawbreaker is amusing to play around with in a room full of people! Players who lose out and are killed by the jawbreaker can simply teleport back to the room, so there isn't much harm done.

<BR></P>

<P>Thanks to Jen &quot;Tourmaline&quot; Kleiman for providing the idea behind this example.

<BR></P>

<H3><A ID="I88" NAME="I88">

<FONT SIZE=4><B>Programming a MUSE</B>

<BR></FONT></A></H3>

<P>MUSE, a variation and elaboration of MUSH, is written in a language called TinyMUSE, another spin-off of the original TinyMUD. TinyMUSE was first implemented in a popular simulated environment called MicroMUSE. This on-line environment was first 
conceived in 1990 by programmer Stan Lim (&quot;Jin&quot;), who built the original environment in Larry Foard's TinyMUSH<I> </I>programming language. &quot;Cyberion City,&quot; as it came to be called, is a beautiful vision of a utopian society in an 
orbital station high above the Earth, complete with talking robots, spaceships, and otherworldly adventures. As the years went by and the source code was refined and elaborated upon, the newer language became known as TinyMUSE,<I> </I>and a specialized 
client program, called TinyFugue<I> </I>(also commonly known as <I>tf</I>) was developed to interface with the MUSE during play. TinyMUSE worlds come in a variety of flavors, but the language has become a favorite of many educators because of its ease of 
use, and its firm but modifiable &quot;social structure.&quot;

<BR></P>

<P>Almost all of the capabilities of MUSHes can also be found in MUSEs. MUSEs also have a few idiosyncracies all their own, such as a heirarchical player class system.

<BR></P>

<H4><A ID="I89" NAME="I89">

<FONT SIZE=3><B>Popular MUSEs</B>

<BR></FONT></A></H4>

<P>There are a few thematic MUSEs out there, but the granddaddy MUSE is MicroMUSE.

<BR></P>

<TABLE BORDER>

<TR>

<TD>

<PRE><B><I>Name</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Machine Name</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Internet </I></B><B><I>Address</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Port</I></B>

<BR></PRE>

<TR>

<TD>

<P>MicroMUSE</P>

<TD>

<P>chezmoto.ai.mit.edu</P>

<TD>

<P>18.43.0.102</P>

<TD>

<P>4201</P>

<TR>

<TD>

<P>Rhostshyl</P>

<TD>

<P>rhostshyl.cit.cornell.edu</P>

<TD>

<P>128.253.180.15</P>

<TD>

<P>4201</P>

<TR>

<TD>

<P>TimeMuse</P>

<TD>

<P>murren.ai.mit.edu</P>

<TD>

<P>18.43.0.179</P>

<TD>

<P>4201</P>

<TR>

<TD>

<P>TrekMUSE</P>

<TD>

<P>grimmy.cnidr.org</P>

<TD>

<P>128.109.179.14</P>

<TD>

<P>1701</P></TABLE>

<P>These addresses are current as of August, 1994. Keep in mind that they may change.

<BR></P>

<P>MicroMUSE, a popular simulated environment based at MIT, was first conceived in 1990.

<BR></P>

<P>TinyFugue, the TinyMUSE client, is available via anonymous FTP to chezmoto.ai.mit.edu and may be found in the pub/muse directory as tf.33a5.tar.gz.

<BR></P>

<H4><A ID="I90" NAME="I90">

<FONT SIZE=3><B>MuseNet Worlds</B>

<BR></FONT></A></H4>

<P>There are a growing number of TinyMUSE worlds on the Net, of which those listed here represent merely a sample. A number of educational TinyMUSE worlds were incorporated into a single overarching structure known as MuseNet (the Multi-User Science 
Education Network); any of these worlds may be reached via telnet to any of the affiliated sites.

<BR></P>

<P>With the TinyFugue client, you can instantly open bamf portals between any of these worlds, allowing your character to toggle between worlds at a whim. To see a list of available worlds, simply type /listwords from within TinyFugue. To open a connection 
to another MuseNet world, type /world <I>world-name</I>, and then type ESC-B to bamf through the portal.

<BR></P>

<P>The current list of MuseNet worlds includes MicroMuse, BridgeMuse, MariCopa, CyberLib, and EcoMuse. MuseNet worlds can be reached via telnet at any of the following addresses:

<BR></P>

<PRE>musenet.bbn.com

micro.bbn.com

muse.usmee.maine.edu

micro.usmee.maine.edu

bridges.usmee.maine.edu

pico.usmee.maine.edu

femto.usmee.maine.edu

cyberion.usmee.maine.edu

nano.usmee.maine.edu

atto.usmee.maine.edu</PRE>

<H3><A ID="I91" NAME="I91">

<FONT SIZE=4><B>Things Specific to MUSEs</B>

<BR></FONT></A></H3>

<P>The MUSE environment allows for <I>classes</I> of programming capability to be distributed by the MUSE Directors, according to the talent and drive of individual players. The learning curve is therefore broken into a series of <I>plateaus</I>, allowing 
players to progress at their own speed. The following things are specific to MUSEs.

<BR></P>

<H4><A ID="I92" NAME="I92">

<FONT SIZE=3><B>Commands</B>

<BR></FONT></A></H4>

<P>There are a few common commands that MUSEs have, in addition to those described in the &quot;Overview of Common Commands&quot; section, earlier in this chapter.

<BR></P>

<P>The money command shows your current number of credits and the value of all your assets.

<BR></P>

<P>The news command displays the current newsfile, which you should check regularly.

<BR></P>

<H4><A ID="I93" NAME="I93">

<FONT SIZE=3><B>Classes</B>

<BR></FONT></A></H4>

<P>In TinyMUSE worlds, programming capabilities (powers) and virtual civic duties are conjoined rather formally in a hierarchic structure of roles: <I>Visitor</I>,<I> Citizen</I>,<I> Guide</I>,<I> Official</I>,<I> Corporation</I>,<I> Administrator</I>,<I> 
</I>and <I>Director </I>(the specific duties and powers of each class are determined by the Directors of any given MUSE, and may be set to affect all <I>lower-ranked </I>users, all <I>equally ranked </I>users, or <I>all </I>users). This system tends to 
ensure that those players entrusted with powerful characters act in a responsible and accountable manner.

<BR></P>

<P>Moving around in the virtual environment and playing with other people's creations is an enjoyable pastime, but the real action begins when you decide to become a MUSE Citizen. At this point, you receive a real character (having been known as guest up 
until now), and some building privileges. Your character, provided by the officials of the MUSE, will have a name and an associated password, and probably very little else.

<BR></P>

<P>The function

<BR></P>

<PRE>class(<I>player</I>)</PRE>

<P>can be used to access a player's class in MUSE programs.

<BR></P>

<P>You can also use functions that access player's powers:

<BR></P>

<PRE>controls(<I>player1, player2, power</I>)</PRE>

<P>returns 1 if player1 has the specified power over player2. Otherwise it returns 0.

<BR></P>

<PRE>haspow(<I>object, power</I>)</PRE>

<P>returns 1 if the object has the specified power. Otherwise it returns 0.

<BR></P>

<H4><A ID="I94" NAME="I94">

<FONT SIZE=3><B>Zones</B>

<BR></FONT></A></H4>

<P>MUSEs have specialized rooms called <I>zones</I>. A zone is a group of rooms acting as if it were one big room. Messages that are sent to a room in the zone can be heard throughout the zone. For instance, you can create a long hallway, composed of three 
rooms, such as the West End of the hallway, the Middle of the hallway, and the East End of the hallway. Players can be located in any of these three rooms. Then, you can group the three rooms into a zone room. Certain messages that are sent to the zone can 
be heard by everyone in the hallway rooms. In this manner, you can create large rooms that seem to have a depth to them. You can create a ballroom or a large dance floor using a zone.

<BR></P>

<P>To link a room into a zone, use the command:

<BR></P>

<PRE>@zlink room = <I>zone-object</I></PRE>

<P>And to emit a message to everyone in the zone, use:

<BR></P>

<PRE>@zemit <I>zone-object</I> = <I>message</I></PRE>

<P>There are also a few functions you can use in MUSE code that relate to zones. The function

<BR></P>

<PRE>zone(<I>object</I>)</PRE>

<P>operates on a given object. If the object is a room, the room's zone is returned. If the object is an exit, thing, or player, the DBREF of the zone that the object is in is returned.

<BR></P>

<P>Additionally, the function

<BR></P>

<PRE>zwho(<I>zone-object</I>)</PRE>

<P>returns a list of the DBREFs of all the players in the zone, and the function

<BR></P>

<PRE>inzone(zone-object)</PRE>

<P>returns a list of all the rooms that have been z-linked to the zone.

<BR></P>

<H4><A ID="I95" NAME="I95">

<FONT SIZE=3><B>Interactive Narration: &quot;Monster Island&quot; Example</B>

<BR></FONT></A></H4>

<P>In an object-oriented environment, directing players where you want them to go can be tricky. If done inartistically, linearity can be easily overdone, making things seem like a slow-moving sequence of still images. The trick is to balance the decision 
to &quot;opt out&quot; of a storyline with various &quot;lures in&quot; to the storyline. It also doesn't hurt to make every room alive with incidental action.

<BR></P>

<P>The following environment is excerpted from Tod Foley's &quot;Monster Island,&quot; a 1920's pulp adventure MUSE narrative with a fairly strong overarching plotline. The story begins in a dark, secluded bay...

<BR></P>

<PRE>Blackmoor Bay(#248Rpv)</PRE>

<P>The waters of Blackmoor Bay are a deep indigo. Dark waves lap the sandy shore in a mesmerizing rhythm, and a chilly seabreeze sends a shiver up your spine. Rumors claim that this Cove is home to a host of lost seafaring souls, sailors whose ships were 
destroyed by the merciless might of The Great Sea...

<BR></P>

<PRE>Contents:

ship(#252SeoK)

Obvious exits:

Shore  Sea</PRE>

<P>A combination of locks were used to keep people from traveling straight out into the sea. The @fail message for this exit describes the biting wind and stinging spray. Although there are a few clues lying around on the shore, the objective is for 
players to get out to sea.

<BR></P>

<PRE>enter ship

ship(#252SeoK)</PRE>

<P>The ship is stocked and ready to sail, despite the fact that no crew can be found. The hull is old and the sails slightly torn, but she seems seaworthy enough. Care to set sail?

<BR></P>

<PRE>Obvious exits:

bay  climb mast</PRE>

<P>Typing climb mast leads you to the crowsnest, where you can see the entire surrounding area (and perhaps discern another clue); it also allows you to jump straight into the cold waters of Blackmoor Bay, just for fun. The desire was to structure this 
adventure so that one party could come along fairly soon after the previous one, so the ship had to stay here. If you examine the code, you see that that's exactly what it does. The @va register waits to hear the magic words &quot;set sail&quot; to issue 
you the exit name:

<BR></P>

<PRE>ex here

ship(#252SeoK)</PRE>

<P>This dilapidated old vessel looks like she's weathered a few storms, but she's rigged and ready to sail. You see no movement onboard. Dare you enter?

<BR></P>

<PRE>Owner: Speedy  Credits: 1

Type: Thing      Flags: sticky enter_ok opaque key

Zone: Universal Zone

Created: never

Modified: never

Idesc:The ship is stocked and ready to sail, despite the fact that no crew can be found. The hull is old and the sails slightly torn, but she seems seaworthy enough. Care to set sail?

Va:$set sail:@PEmit %N=You take the helm, piloting the ancient vessel northward to the mouth of the Bay. The Sea looks especially rough for this time of year... What's your call - `sea' or `bay'?

Contents:

Speedy(#5Pevcn)

Home: Blackmoor Bay(#248Rpv)

Location: Blackmoor Bay(#248Rpv)

Exits:

bay(#372Ev)

sea(#371EDv)

climb mast;up;climb(#251Ev)</PRE>

<P>First we head out to sea...

<BR></P>

<PRE>sea

You boldly set forth into the fierce and mysterious Sea...

The Great Sea(#250RvJ)</PRE>

<P>You head out into The Great Sea, fierce winds blowing in your hair, salty spray hitting your face... you begin to fear for your safety as the sky darkens and the waves grow higher... you have no idea which direction you're facing anymore...

<BR></P>

<PRE>Obvious exits:

&lt;I&gt;sland  &lt;B&gt;ay</PRE>

<P>After a second or two, we see...

<BR></P>

<PRE>You fear a storm is approaching...</PRE>

<P>And after another second or two...

<BR></P>

<PRE>The sky begins to draw dark as the clouds above gather in disturbing thickness...</PRE>

<P>The pressure's really getting to you by now, isn't it? Well, the clue in the crowsnest is a scrawled note reading &quot;Ye better pray, matey.&quot; And, in true literal fashion, players who type anything beginning with p-r-a-y will be rewarded by the 
following line of code (from register @va of The Great Sea):

<BR></P>

<PRE>Va:$pray*:@PEmit %N=Your prayers have been answered, %N. The sky begins brightening as the clouds part, and a lovely rainbow arches overhead. You see a single white dove heading toward an island that wasn't there a minute ago... ;@tr me/vb</PRE>

<P>All in all, it really hasn't taken very much work&#151;two rooms and two things&#151;to get the players fairly immersed in the adventure. They've experienced a little thrill and a small miracle, and feel as though they're far from &quot;home.&quot; At 
this point, we could allow players a chance to move on through other exits and travel to other realms. By linking exits to the rooms of fellow MUSErs, the Sea becomes Great indeed. Once the players commit to debarking upon the island, however, the 
narrative picks up in full swing:

<BR></P>

<PRE>island

River Mouth(#373R)</PRE>

<P>The river is narrow, the water dark, and the smell is horrid. You push aside some of the hanging vines that obscure your view, and peer ahead. Overhead, several carrion-birds circle slowly, patiently waiting...

<BR></P>

<PRE>Obvious exits:

&lt;S&gt;wamp  &lt;J&gt;ungle  Sea</PRE>

<P>One easy way to create the feeling of &quot;life&quot; in environments like these is by using @wait commands in the @adesc line, like this:

<BR></P>

<PRE>Adesc:@Wait 5=@Emit A mutant rodent on the north bank is startled by your passage. It freezes, limbs locked, staring at you.;@Wait 15=@Emit A slimy tentacle suddenly erupts from the water. It grasps the small mammal, which quickly sinks its teeth into 
the attacker's squishy flesh. Thus released, the little rat-thing scampers away into the underbrush, and the tentacle retreats silently into the brackish water.</PRE>

<P>You can also make use of the rand() function to vary the local wildlife a little bit. After picking up a machete from the swamp to the north (you'll understand why in a moment), we'll move south into the jungle:

<BR></P>

<PRE>Jungle(#376R)</PRE>

<P>The vegetation is immense and unusual, and the sounds you hear around you are like no animals you can identify. You feel as though you are being watched by some lurking malevolence...

<BR></P>

<PRE>Obvious exits:

&lt;E&gt;ast  &lt;N&gt;orth</PRE>

<H3><A ID="I96" NAME="I96">

<FONT SIZE=4><B>After a few seconds, we see...</B>

<BR></FONT></A></H3>

<PRE>The jungle is getting too thick to push your way through... Branches tear your clothes and scratch your face... You have to stop and rest for a minute...</PRE>

<P>Now there are two moves players can make. The first is to use the machete we got from the swamp (note that if the player came here first, this area would seem pretty useless, causing them to go across the river to the swamp room, where they'd find the 
machete). Used here, the machete will hack a way through the trees for us. But there's another clue hidden in the words above; let's see what happens if we type rest:

<BR></P>

<PRE>rest</PRE>

<P>You settle back against a tree and catch your breath. This jungle-cutting is no easy feat! The smooth curve of the trunk behind you feels comfortable, and you close your eyes, drifting into a much-deserved slumber.

<BR></P>

<PRE>...

You dream of a better life...

...

One with much less excitement and regular paychecks...

...

Dream on...</PRE>

<P>You are awakened by a deafening roar from the east. What could you have been thinking? You scramble to your feet and scan the surrounding area, looking for anything you'd hope not to see...

<BR></P>

<PRE>Scary!  But if the player waits just a little while longer, they'll be rewarded again:

The roar is not repeated, and you cannot pinpoint its

source, but there's a tall tree nearby with a man's jacket stuck in the highest branches.

Huh -- what's this?  Only one way to find out:

climb tree</PRE>

<P>You pull yourself to the top of the tall tree, trying not to look down too often. At last you reach a point where you can climb no further.

<BR></P>

<PRE>Top of Tall Tree(#379R)</PRE>

<P>You are hanging in a precarious position from the top of one of the tallest trees on the island. From here you can see your ship and most of the river valley. You notice that many of the ancient trees are bent or broken at odd

<BR></P>

<PRE>angles...

Contents:

Jacket(#382S)

Obvious exits:

down</PRE>

<P>Where's that jacket?

<BR></P>

<PRE>look jacket</PRE>

<P>This khaki jacket has been shredded by some amazingly powerful attacker. It's covered with dark brown stains, and seems to have something in the left pocket...

<BR></P>

<PRE>take jacket</PRE>

<P>You can't pull the jacket loose from the branches, but you manage to reach into the pocket... It feels like a small notebook...

<BR></P>

<PRE>take notebook</PRE>

<P>You grab the notebook quickly, and a few pages scatter to the wind.

<BR></P>

<PRE>read notebook

Small Notebook(#383SD)</PRE>

<P>It's the battered journal of an adventurer named (something illegible) Westcott. Most of the pages are either missing or too badly damaged by the elements to read, but the last entry is fairly clear. &quot;Most of my crew have deserted me,&quot; writes 
Westcott, &quot;and I cannot say I blame them, for it is true what they say of this island&#151;it is inhabited, nay, RULED, by a gigantic reptilian creature. I have therefore decided to name this place Monster Island.&quot;

<BR></P>

<P>You get the picture. We'll leave off right there, just to keep you wondering.

<BR></P>

<H3><A ID="I97" NAME="I97">

<FONT SIZE=4><B>MUCK, MUSH and MUSE Reference</B>

<BR></FONT></A></H3>

<P>This section provides a detailed reference to MUCKs, MUSHes, and MUSEs. It lists at-commands, common functions, flags, and other mud commands and structures.

<BR></P>

<H4><A ID="I98" NAME="I98">

<FONT SIZE=3><B>Concept Reference</B>

<BR></FONT></A></H4>

<P>As an aid for your memory, this section summarizes some basic mud concepts.

<BR></P>

<H4><A ID="I99" NAME="I99">

<FONT SIZE=3><B>Control</B>

<BR></FONT></A></H4>

<P>In general, you can examine, modify, or use any object you control, and you control only the objects you own (unless you're a Wizard or an Official). The single exception to this rule is an unlinked exit; anyone can link to it, causing the exit to be 
@chown'ed to them, and effectively stealing the exit from its original owner. Builders should be aware of this.

<BR></P>

<H4><A ID="I100" NAME="I100">

<FONT SIZE=3><B>Costs</B>

<BR></FONT></A></H4>

<P>Certain commands cost credits to perform.

<BR></P>

<TABLE BORDER>

<TR>

<TD>

<PRE><B><I>Command</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Cost</I></B>

<BR></PRE>

<TR>

<TD>

<P>page</P>

<TD>

<P>1 credit each</P>

<TR>

<TD>

<P>@dig</P>

<TD>

<P>1 credit each</P>

<TR>

<TD>

<P>@link</P>

<TD>

<P>1 credit if you did not own the exit, plus 1 to the previous owner</P>

<TR>

<TD>

<P>@open</P>

<TD>

<P>1 credit, plus 1 more if the exit is linked at the same time</P>

<TR>

<TD>

<P>@create</P>

<TD>

<P>10 credits or more (up to 505 credits)</P>

<TR>

<TD>

<P>@wait</P>

<TD>

<P>10 credits each</P>

<TR>

<TD>

<P>@find</P>

<TD>

<P>10 credits each</P>

<TR>

<TD>

<P>@search</P>

<TD>

<P>10 credits each</P>

<TR>

<TD>

<P>@announce</P>

<TD>

<P>250 credits.</P>

<TR>

<TD>

<P>@trigger</P>

<TD>

<P>Anywhere from 1/64th to 1/16 of a credit</P>

<TR>

<TD>

<P>@force</P>

<TD>

<P>Anywhere from 1/64th to 1/16 of a credit</P></TABLE>

<P>Certain commands demand deposits, which are refunded when the object is destroyed.

<BR></P>

<H4><A ID="I101" NAME="I101">

<FONT SIZE=3><B>Credits</B>

<BR></FONT></A></H4>

<P>In the enlightened words of Moulton (Barry Kort), &quot;Credits are really chits for CPU cycles.&quot; In other words, don't take anything about them too personally&#151;they're not even really <I>fake </I>money. You receive an allowance of credits 
every day you connect with the mud. You may also borrow money, or sell the objects you create.

<BR></P>

<H4><A ID="I102" NAME="I102">

<FONT SIZE=3><B>Drop-To</B>

<BR></FONT></A></H4>

<P>When an @link is used on a room, it also creates a drop-to location. From then on, any object dropped in the room will go to that location (unless the room is STICKY). If the room is STICKY, the drop-to will be delayed until the last person has left.

<BR></P>

<H4><A ID="I103" NAME="I103">

<FONT SIZE=3><B>Enactor</B>

<BR></FONT></A></H4>

<P>For any action that occurs, the enactor is the object that causes a given action to occur. If an object initiates an action by an @force or @trigger, it is the enactor of the specified action. If one of your objects initiates an action by an @asucc, 
@afail, or @aenter, you are the enactor; the action will occur just as if you had typed it yourself. Interactive Design Note: When an action begins running, the name of its enactor is plugged into the %N and %n variables.

<BR></P>

<H4><A ID="I104" NAME="I104">

<FONT SIZE=3><B><I>$</I></B><B> and </B><B><I>!</I></B><B> Events</B>

<BR></FONT></A></H4>

<P>These extremely useful events enable you to define new verbs and &quot;automatic&quot; commands. Stored in any register of any class of object, they wait until their specific text pattern comes along, and then they execute their listed actions.

<BR></P>

<P><I>$ events </I>wait until their pattern is matched by any typed command (by any player in the room):

<BR></P>

<PRE>$<I>pattern</I>:<I>action1</I>[;<I>action2</I>][;...]</PRE>

<P><I>! events </I>are similar, except that they listen for &quot;spoken&quot; words instead of typed commands:

<BR></P>

<PRE>!<I>pattern</I>:<I>action1</I>[;<I>action2</I>][;...]</PRE>

<P>In either case, the pattern may include wild cards. If it does have wild cards, the strings matching them is plugged in as temporary variables, and may be referenced in the action<I> </I>part of the command. The first such variable will be called %0 or 
v(0), the second %1 or v(1), and so forth.

<BR></P>

<H4><A ID="I105" NAME="I105">

<FONT SIZE=3><B>Exits</B>

<BR></FONT></A></H4>

<P>Exits are created by the @open command, but they will only be automatically linked to a given room if this is specified. If unspecified (or if the exit is created from within another type of object), you must then use an @link command to link the exit 
to where it goes. If you ever find yourself in a place with no obvious exits, you may be inside a thing. The leave command will get you out.

<BR></P>

<H4><A ID="I106" NAME="I106">

<FONT SIZE=3><B>Failure</B>

<BR></FONT></A></H4>

<P>Failure has different meanings in different contexts. You fail to use a thing when you cannot take it (due to locks, for instance). You fail to use an exit when you cannot go through it. You fail to use a room when you cannot look at it.

<BR></P>

<H4><A ID="I107" NAME="I107">

<FONT SIZE=3><B>Home</B>

<BR></FONT></A></H4>

<P>To teleport instantly to your home, type home at any time. To set a new one, use the @link command (the target room must either be yours or have its LINK_OK flag set). All players and things have homes; this is the place where STICKY objects go when you 
drop them. For things, the default home is the room in which they were created. To @link an exit that sends players back to their own homes:

<BR></P>

<PRE>&gt; @link <I>exit-name</I>=home</PRE>

<H4><A ID="I108" NAME="I108">

<FONT SIZE=3><B>Linking</B>

<BR></FONT></A></H4>

<P>You can only @link to rooms you control, and rooms that are set LINK_OK. An @link performed on a thing sets the object's home.

<BR></P>

<H4><A ID="I109" NAME="I109">

<FONT SIZE=3><B>me</B>

<BR></FONT></A></H4>

<P>You can use the term me to refer to your character.

<BR></P>

<H4><A ID="I110" NAME="I110">

<FONT SIZE=3><B>Names</B>

<BR></FONT></A></H4>

<P>To have an object refer to a players' name, use the variable %N in your command statement. If, for some strange reason, you wish not to capitalize the name, use %n instead.

<BR></P>

<H4><A ID="I111" NAME="I111">

<FONT SIZE=3><B>NULL Exits: Bogus Commands</B>

<BR></FONT></A></H4>

<P>It's easy to come up with &quot;bogus commands&quot; by creating unusable exits. Here's an example that seemingly grants the power of flight:

<BR></P>

<PRE>&gt; @open fly

&gt; @link fly=here

&gt; @lock fly=me&amp;!me

&gt; @fail fly=You suddenly rise, flying high above the ground!

&gt; @ofail fly=rises up overhead, flying through the air!</PRE>

<P>The exit was linked so that no one could steal it, and locked so that no one could successfully use it (since it's impossible to be both &quot;me&quot; and not &quot;me&quot;). Since nobody can go through this &quot;exit,&quot; it always fails. The 
@fail message is displayed to the player, and the @ofail message (preceded by the player's name) is shown to everyone else.

<BR></P>

<H4><A ID="I112" NAME="I112">

<FONT SIZE=3><B>Numbers</B>

<BR></FONT></A></H4>

<P>All objects in the mud are known by a database reference number, called a DBREF for short. The DBREF of any object you own shows up whenever you look at the object; others do not see it. To have an object refer to the DBREF of another object, use the 
variable %# in your command statement.

<BR></P>

<H4><A ID="I113" NAME="I113">

<FONT SIZE=3><B>Objects</B>

<BR></FONT></A></H4>

<P>There are only four types of objects in muds: <I>rooms</I>,<I> exits</I>,<I> things</I>, and <I>players</I>.

<BR></P>

<P>The first letter following an object's ID number indicates its type (<I>R</I>, <I>E</I>, <I>T</I>, or <I>P</I>). <I>Rooms </I>are objects that can contain other objects and linked exits. <I>Exits </I>are the means by which objects move between rooms and 
things. <I>Things </I>are inanimate objects that can be carried. <I>Players </I>are animate objects that can move and carry (contain) other objects.

<BR></P>

<H4><A ID="I114" NAME="I114">

<FONT SIZE=3><B>Pronouns</B>

<BR></FONT></A></H4>

<P>Mud objects can be made to refer directly to players, by pronoun as well as by name. This is one of the areas where normal English grammar becomes a little tricky to program, so a number of special variables has been set aside as pronoun-substitution 
characters. There are five &quot;sexes&quot; available in most mud worlds: male, female, neuter, plural, and &quot;spivak&quot; (a genderless system that lops off S's and H's). Objects without sex of any kind will have their names used instead of pronouns; 
but this makes for inelegant narrative. For instance: &quot;Speedy shines the apple on Speedy's chest and bites into it with a gleam in Speedy's eye.&quot; Bleagh. The results of the shown variables for all five sexes are as follows:

<BR></P>

<TABLE BORDER>

<TR>

<TD>

<PRE><B><I>Variable</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Type</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Example</I></B>

<BR></PRE>

<TR>

<TD>

<P>%S, %s</P>

<TD>

<P>Subjective pronoun</P>

<TD>

<P>he, she, it, they, e</P>

<TR>

<TD>

<P>%O, %o</P>

<TD>

<P>Objective pronoun</P>

<TD>

<P>him, her, it, them, em</P>

<TR>

<TD>

<P>%P, %p</P>

<TD>

<P>Possessive pronoun</P>

<TD>

<P>his, her, its, their, eir</P>

<TR>

<TD>

<P>%A, %a</P>

<TD>

<P>Absolute possessive pronoun</P>

<TD>

<P>his, hers, its, theirs, eirs</P></TABLE>

<H4><A ID="I115" NAME="I115">

<FONT SIZE=3><B>Stack</B>

<BR></FONT></A></H4>

<P>The stack for any object consists of the contents of the numbered stack variables: v(0) through v(9). You can set these contents in various ways; they may be edited directly, entered as actions in an @trigger command, or replaced by wild card 
substitutions.

<BR></P>

<P>In MUCK, the stack is the an actual stack of things. You create MUF programs that manipulate the stack.

<BR></P>

<H4><A ID="I116" NAME="I116">

<FONT SIZE=3><B>Substitutions</B>

<BR></FONT></A></H4>

<P>Several types of % variables (variable substitution characters) have already been discussed (see &quot;Names,&quot; &quot;Numbers,&quot; and &quot;Pronouns&quot;). There are a few others reserved for use, which make programming quite a bit easier. The 
values of an object's V-registers may be accessed by the variables %va through %vz.

<BR></P>

<H4><A ID="I117" NAME="I117">

<FONT SIZE=3><B>Success</B>

<BR></FONT></A></H4>

<P>Success has different meanings in different contexts. You succeed in using a thing when you take it. You succeed in using an exit when you go through it. You succeed in using a room when you look around.

<BR></P>

<H4><A ID="I118" NAME="I118">

<FONT SIZE=3><B>V-Registers</B>

<BR></FONT></A></H4>

<P>V-registers are the main means of programming objects. Each object has 10 numbered stack variables, v(0) through v(9), and 26 V-registers, named v(va) through v(vz). Each V-register can hold a number, a character string, or an executable command.

<BR></P>

<H4><A ID="I119" NAME="I119">

<FONT SIZE=3><B>Verb Commands</B>

<BR></FONT></A></H4>

<P>Most verb commands come in three forms:

<BR></P>

<P>verb (what the enactor sees)</P>

<P>overb (what others in the room see)</P>

<P ALIGN="CENTER">

<CENTER>averb (the action triggered when the verb event happens)</CENTER></P>

<H4><A ID="I120" NAME="I120">

<FONT SIZE=3><B>Tips For Programmers</B>

<BR></FONT></A></H4>

<P>You can easily spend a few years using the commands given in the last section, and create thousands of masterpieces of textual art (and many have done just that!). There are, however, a good number of advanced features that prove invaluable when it 
comes to fine-tuning the behavior of your mud objects, both as individual units and&#151;even better&#151;as interconnected parts of an <I>interactive environment</I>. This section provides a reference for many of those features and functions.

<BR></P>

<P>Your first interactive environment may consist of nothing more than one densely coded room full of chatty objects, or you may choose to bite off a dozen connected rooms. In either case, you still have a little way to go.

<BR></P>

<P>When you create a room and place a couple of objects in it, you tend to begin developing a theme of sorts. This theme may be as loose as &quot;fantasy,&quot; or as tightly focused as &quot;a rowdy roadside bar located in a traveling tent, sometime 
during the early seventies.&quot; Follow these thematic threads and pick out the most important items, places, and characters. As you continue creating these initial elements of your environment, certain objects will, by their very nature, imply others. Be 
careful&#151;these other objects will imply others beyond them, and the process may begin to exponentiate beyond reckoning (resulting in nothing but a bad case of programmer's shock!). If you don't develop things a little at a time, you're bound to get 
trampled under your own ideas. This can lead to hastily constructed mud environments that are of poor quality.

<BR></P>

<P>So as not to draw the ire of the wizards, you might stick to a small series of related rooms at first, adding objects and attributes a little bit at a time. Having kept a list of related objects and ideas, begin adding one or two objects at a time into 
your area. After creating and describing these new objects, go around your entire area again and add a level of detail.

<BR></P>

<P>Here are some guidelines to help:

<BR></P>

<OL>

<LI>Limit yourself to a certain number of initial objects, say 10 or 12.

<BR>

<BR></LI>

<LI>@create them and @desc them, and @link your exits.

<BR>

<BR></LI>

<LI>Add @ofails, @adescs, and such to enhance the narrative.

<BR>

<BR></LI>

<LI>Jot down any other ideas you have on a nearby piece of paper.

<BR>

<BR></LI>

<LI>Think about how these objects might interact with players, and with each other.

<BR>

<BR></LI>

<LI>Take a break! Then add more to your creation in an iterative fashion.

<BR>

<BR></LI></OL>

<P>It is also important to remember that all your objects take up space in the database, so be considerate and thoughtful when you create new areas and objects. Avoid creating low quality objects that just clutter up the database. Strive for interesting 
rooms and innovative objects that mesh with the theme and tone of the mud.

<BR></P>

<H3><A ID="I121" NAME="I121">

<FONT SIZE=4><B>At-Commands Reference</B>

<BR></FONT></A></H3>

<P>In this section, the term <I>action</I> is frequently used. Any basic command or at-command may be used as an action. These actions occur sequentially if separated by semicolons. For example:

<BR></P>

<PRE>&gt; @wait 5=say Hi!;@Emit %N sounds funny.;say Do you think I sound funny?</PRE>

<P>will wait for 5 seconds and then display:

<BR></P>

<PRE>Speedy says &quot;Hi!&quot;

Speedy sounds funny.

Speedy says &quot;Do you think I sound funny?&quot;</PRE>

<P>Note that you may have to enclose your action list in braces if your messages contain commas or semicolons.

<BR></P>

<H4><A ID="I122" NAME="I122">

<FONT SIZE=3><B>At-Commands</B>

<BR></FONT></A></H4>

<P>Some commands in this section are only available on certain types of muds. These commands are listed as such. Certain commands may also only be available to wizards or MUSE officials, and they are likewise denoted.

<BR></P>

<PRE>@aahear <I>object</I>=<I>actions</I></PRE>

<P>At All Hear. Sets the actions triggered when the @listen string is matched by a pose or utterance from the object itself or from a player.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@aclone <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered by the newly cloned copy when the object is cloned.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@aconnect <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when someone connects into the mud. On a room or object in the room, it's triggered by connection within the room.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@addparent <I>object</I>=<I>parent</I></PRE>

<P>Gives the object a new parent. The parent must be controlled by you or be set BEARING. The object inherits attribute definitions<I> </I>from its parents. It also inherits attribute values, if the attributes in question have the INHERIT option set.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@adesc <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when the object is looked at.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@adisconnect <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when someone disconnects from the mud. On a room or an object in the room, it's triggered by a disconnection within the room.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@adrop <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when the object is dropped.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@aefail <I>room</I>|<I>object</I>|<I>player</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when someone fails to enter the room, object, or player.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@aenter <I>room</I>|<I>object</I>|<I>player</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when the room, object, or player is entered.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@afail <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when an attempt to use the object fails.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@ahear <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when the object's @listen string is matched.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@aleave <I>room</I>|<I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when a player or other object leaves the specified room or object.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@alfail <I>room</I>|<I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when someone fails an attempt to leave the room or object.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@alias <I>player</I>=<I>alias</I></PRE>

<P>Sets the alias by which to reference the player.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@allquota <I>number</I></PRE>

<P>Sets the builder's quota for all players to the number entered. Individual players can check their own quotas with the @quota command (see @quota later in this section).

<BR></P>

<P>Wizards and Officials only.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@amhear <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when the object's @listen string is matched by a pose or utterance from the object itself.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@amove <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message emitted if the object moves by any means.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@announce <I>message</I></PRE>

<P>Broadcasts the specified message to every player connected. Costs 250 credits. Players can block out announcements by setting themselves NO_WALLS. Abbr.: @ann.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@apage <I>player</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when you are on-line and receive a page.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@apay <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when someone or something gives credits to the object.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@apemit <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when the object gets an @pemit.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@asfail <I>room</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when someone fails to use an @slock.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@asucc <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when the object is successfully used.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@aufail <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when someone fails to use the object due to @ulock.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@awhisper <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when the object receives a whisper.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@broadcast <I>message</I></PRE>

<P>Broadcasts the given message throughout the mud. Nonblockable.

<BR></P>

<P>MUSE only.

<BR></P>

<P><B>Wizards and Officials Only.</B>

<BR></P>

<PRE>@boot <I>player</I>

Disconnects the player from the game.

Available on MUCK, MUSH and MUSE.</PRE>

<P><B>Wizards and Officials Only.</B>

<BR></P>

<PRE>@charges <I>object</I>=<I>#charges</I></PRE>

<P>Limits the number of times an action can be used.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@chown <I>object</I>=<I>player</I></PRE>

<P>Changes the ownership of the object to the specified player, turns on the object's HAVEN flag, and turns off the object's INHERIT flag.

<BR></P>

<P>Available on MUCK, MUSH and MUSE.

<BR></P>

<PRE>@chownall <I>player1</I>=<I>player2</I></PRE>

<P>Transfers the ownership of all of player1's possessions to player2.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<P><B>Wizards and Officials Only.</B>

<BR></P>

<PRE>@clone <I>object</I></PRE>

<P>Creates a duplicate of the object in the current room.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@columns <I>#columns</I></PRE>

<H3><A ID="I123" NAME="I123">

<FONT SIZE=4>Sets the number of columns that WHO prints. The default is 80.

<BR></FONT></A></H3>

<P>MUSE only.

<BR></P>

<PRE>@cost <I>object</I>=<I>#credits</I></PRE>

<P>Sets the number of credits that must be given to the object to trigger @pay, @opay, and @apay.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@cpattr <I>new-object</I>/<I>new-attribute</I>=<I>old-object</I>/<I>old-attribute</I></PRE>

<P>Copies an <I>attribute definition </I>from the old object to the new object. The names of the two attributes used need not be the same.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@create <I>object-name</I>[=<I>#credits</I>]</PRE>

<P>Creates a new object whose name is the specified object-name. The command costs <I>#credits</I> or 10 credits, whichever is greater. The object's &quot;actual&quot; value will become (<I>#credits</I><I> </I>/ 5) - 1.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@dbck</PRE>

<P>Shows any disconnected rooms and clears the free list.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@dbtop <I>item</I></PRE>

<P>Shows the top list for the specified item in the database. Do @dbtop (without an argument) to see what objects are available to list.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@decompile</PRE>

<P>Outputs a series of commands that can be fed back into the mud to redefine and reset all of an objects' registers and flags. This command can be used to save an object to disk, edit it, and read it back in via the TinyFugue /quote macro. When using 
@decompile for this purpose, be sure to set /wrap off in TinyFugue so that lines are not broken every 80 characters. @decompile displays several commands, including @set (to set flags), @defattr (to define attributes), and @nset (to set attribute values).

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@defattr <I>object</I>/<I>attribute</I>[=<I>option1</I> <I>option2</I> ...]</PRE>

<P>Creates or modifies a user-defined attribute on the object. Any options specified will dictate the behavior of the attribute. The new attribute may be set by typing: @set <I>object</I>=<I>attribute</I>:<I>value</I>, or with the usual shorthand: 
@<I>attribute</I> <I>object</I>=<I>value</I>.For example, @defattr Book/title=osee defines an attribute<I> </I>called title which anyone can see upon doing an examine command (this is the meaning of osee--see @osee), and @title Book=Muse Tutorial places 
the words Muse Tutorial there. Now the function [get(book/title)] returns Muse Tutorial.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@delparent <I>object</I>=<I>parent</I></PRE>

<P>Removes the parent from the object. The parent must be controlled by you, or set BEARING.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@describe <I>object</I>[=<I>text</I>]</PRE>

<P>Sets the text seen when the object is looked at. Abbr.: @desc.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@destroy <I>object</I></PRE>

<P>Sets the object &quot;non-protected&quot; and returns the creator's investment. This command may be aborted by an @undestroy within 10-15 minutes.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@dig <I>room-name</I>[;<I>alternate-names</I>][=<I>exits</I>[,<I>return-exits</I>]]</PRE>

<P>Creates a room, giving it the specified room name. The optional portions allow alternate names and auto-linked exits.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@does <I>object</I>=<I>actions</I></PRE>

<P>Like a v-register, but removes 1 charge from the object when triggered.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@doing <I>message</I></PRE>

<P>Sets the player's @doing message, which is displayed in the WHO list.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@doomsday</PRE>

<P>Set by @destroy, @undestroy, @protect, and @unprotect, doomsday is a number in xtime() format, specifying the system time before which an object should not be destroyed. Objects with the GOING flag set will be destroyed during the first @dbck after the 
time given.

<BR></P>

<P>MUSE only.

<BR></P>

<P><B>Only Officials may set the doomsday attribute directly.</B>

<BR></P>

<PRE>@drop <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message seen when someone drops the object. If entered without a message, it clears any existing message.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@dump</PRE>

<P>Dumps the database for storage (vital to the continued survival of the mud).

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@edit <I>object</I>/<I>attribute</I>={<I>old-string</I>},{<I>new-string</I>}</PRE>

<P>Replaces the first occurrence of the old-string by the new-string. The attribute can be any attribute<I> </I>on the object that holds a string value (for example, @desc, @succ, @adrop, @listen, @ahear, @va, @vb, and so forth). If the strings contain 
only alphabetic characters, the curly braces may be omitted.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@efail <I>object</I>=<I>actions</I></PRE>

<P>Sets the message shown to a player who fails to enter the object.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@elock <I>object</I>=<I>lock</I></PRE>

<P>Sets the enter lock for the object. Only players or things satisfying the lock may then enter the object.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@emit <I>message</I></PRE>

<P>Emits the message to everything in the room. The message can't start with a player's name (in order to prevent spoofing).

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@enter <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message seen when a player enters the object.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@entrances <I>room</I>|<I>object</I></PRE>

<P>Lists all the entrances into the room or object. You must control the room or object.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@fail <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message seen when an attempt to use the object fails. If entered without a message, it clears any existing message.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@find [<I>name</I>]</PRE>

<P>Displays the name and number of every object you control whose name matches the specified name. Costs 10 credits.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@force <I>player</I>|<I>object</I>=<I>actions</I></PRE>

<P>Forces the specified player or object to perform the actions, as though the player or object entered the actions itself. Objects you own can @force you if set INHERIT.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<P><B>Only Wizards or Officials may </B><B>@force</B><B> players.</B>

<BR></P>

<PRE>@foreach <I>list</I>=<I>actions</I></PRE>

<P>Executes the actions (which may be a semicolon-separated list of commands) once for each item in the list (whose elements are separated by spaces). If a %0 occurs in the actions, @foreach substitutes each element of the list, in order, for the %0. Since 
the %0 is evaluated each time the command passes through the command queue, you will need several %'s if the %0 is embedded in function calls.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@getalias <I>player</I></PRE>

<P>Tells you the player's alias, if any.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@giveto <I>player</I>=<I>#credits</I></PRE>

<P>Privately gives an amount of money to the player.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@halt <I>object</I></PRE>

<P>Stops a process or a runaway machine. To stop one particular object, type: @force <I>object</I>=@halt.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@hide</PRE>

<P>Removes you from the WHO list this session. Costs 10 credits.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@huhto <I>player</I>[=<I>E-Mail-Address</I>]</PRE>

<P>Initiates or terminates the automatic logging of failed commands attempted by players in rooms owned by player. The log is periodically mailed to the specified E-Mail-Address. The use of HuhLogs enables a Builder to improve the choice of exit-names and 
trigger verbs in the Builder's realm, in order to better respond to commands most frequently attempted by visitors.

<BR></P>

<P>MUSE only.

<BR></P>

<P><B>Wizards and Officials only.</B>

<BR></P>

<PRE>@idescribe <I>object</I>=<I>message</I></PRE>

<P>Sets the message seen when the object is entered or looked at from the inside.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@leave <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message shown to a player upon leaving the object.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@lfail <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message shown to a player who fails to leave the object.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@link <I>object</I>=<I>room</I></PRE>

<P>For things and players, makes the specified room Home. For rooms, makes the specified room the drop-to room. For exits, makes the specified room the exit's target room (the exit must be unlinked and in your control, or LINK_OK). Costs 1 credit.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@listen <I>object</I>=<I>string</I></PRE>

<P>Listens for the given string to trigger @ahear, @amhear, and/or @aahear. If the string is matched, the object's contents also hear the message.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@llock <I>object</I>=<I>lock</I></PRE>

<P>Sets the leave lock for the object. Only players or things satisfying the lock will be able to leave the object.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@lock <I>object</I>=<I>lock</I></PRE>

<P>Sets the lock on the object. Only players or things satisfying the lock will be able to &quot;succeed&quot; with object (i.e., pick up a thing, go through an exit, trigger @succ, @osucc, @asucc registers, and so forth).

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@move <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message shown to the object itself when it moves by any means.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@name <I>object</I>=<I>new-name</I> [<I>password</I>]</PRE>

<P>Changes the object's name. For a player, it requires the player's password.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@necho <I>message</I></PRE>

<P>Shows a message to you only, but also allows n-phrasing, so you can type multiple spaces and other characters that don't normally come out with @echo. If this command is used in an attribute, it still must be @nset.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@nemit <I>message</I></PRE>

<P>Emits the given message, but does not parse its argument. This can be useful for emitting strings with spaces, brackets, or parentheses in them, without worrying about functions being evaluated or spaces being removed.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@newpassword <I>player</I>=<I>password</I></PRE>

<P>Changes the player's password. The player is informed of the change. If you forget your password, log on as a guest and talk to a Wizard or an Official.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<P><B>Wizards or Officials only.</B>

<BR></P>

<PRE>@npage <I>player</I>=<I>message</I></PRE>

<P>Pages the player without parsing the message.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@npemit <I>object</I>=<I>message</I></PRE>

<P>Emits the specified message to the player, but does not parse its argument. Useful for emitting strings with spaces, brackets, or parentheses in them, without worrying about functions being evaluated or spaces being removed.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@nset <I>object</I>=<I>attribute</I>:<I>actions</I></PRE>

<P>Sets the attribute to the given actions, but does not parse its argument. May be used for setting attribute values with leading or embedded spaces, or with brackets or parentheses, without worrying about functions being evaluated or spaces being 
removed.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@nuke <I>player</I></PRE>

<P>Recycles the player's character, after which it no longer exists.

<BR></P>

<P>MUSE only.

<BR></P>

<P><B>Wizards and Officials only.</B>

<BR></P>

<PRE>@oconnect <I>object</I>=<I>message</I></PRE>

<P>Sets the message shown to everyone but the specified object, when a person connects to the mud.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@odescribe <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message that is seen by the other players in the room when a player looks at the specified object. The message is prefaced by the name of the triggering player. Without a message, the command clears any existing message. Abbr.: @odesc.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@odisconnect<I> object=message</I></PRE>

<P>Sets the message shown to everyone but the specified object when a person disconnects from the mud.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@odrop <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message that is seen by the other players in the room when a player drops the specified object. The message is prefaced by the name of the triggering player. If the object is a room, this sets the message that is displayed to other people when 
someone enters the room. Without a message, it clears any existing message.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@oefail <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message shown to the other players in the room if a player fails to enter the specified object.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@oemit <I>object</I>=<I>message</I></PRE>

<P>Sets the message to be emitted to everything in the room except the object itself.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@oenter <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message that is seen by the other players in the room when a player enters the specified object. The message is prefaced by the name of the triggering player. Without a message, it clears any existing message.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@ofail <I>object</I> [=<I>message</I>]</PRE>

<P>Sets the message that is seen by the other players in the room when a player fails an attempt to use the specified object. The message is prefaced by the name of the triggering player. Without a message, it clears any existing message.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@oleave <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message that is seen by the other players in the room when a player leaves the specified object. The message is prefaced by the name of the triggering player. Without a message, it clears any existing message.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@olfail <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message that is seen by the other players in the room when a player fails to leave the specified object. The message is prefaced by the name of the triggering player. Without a message, it clears any existing message.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@omove <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message seen by all other objects in the room when the specified object moves by any means.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@opay <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message that is seen by the other players in the room when a player or thing pays the specified object. The message is prefaced by the name of the triggering player. Without a message, it clears any existing message.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@open <I>direction</I>[;<I>other-directions</I>] [=<I>#room</I>]</PRE>

<P>Creates an exit in the specified direction(s). If a room number is specified, the exit is linked to that room. Otherwise, the exit remains unlinked. Anyone may use @link to specify where an unlinked exit leads. Costs 1 credit, plus 1 credit more if the 
room number is also specified.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@osfail <I>room</I>=<I>message</I></PRE>

<P>Sets the message shown to everyone in the room, except the enactor, when the enactor fails to use an @slock.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@osuccess <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message that is seen by the other players in the room when a player or thing succeeds in using the specified object. The message is prefaced by the name of the triggering player. Without a message, it clears any existing message. Abbr.: @osucc.


<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@password <I>old-password=new</I>-password</PRE>

<P>Changes your password. Abbr.: @pass.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@pay <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the message shown to the player who pays the specified object. Without a message, it clears any existing message.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@pbreak</PRE>

<P>Shows list of players, broken down into classes.

<BR></P>

<P>MUSE only.

<BR></P>

<P><B>Wizards and Officials only.</B>

<BR></P>

<PRE>@pemit <I>player</I>=<I>message</I></PRE>

<P>Emits the message to a specified player. The message may not start with the name of a player or of an object in the room.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@poof object</PRE>

<P>Teleports the object into itself and then destroys it (if possible). The object disappears from the scene immediately, though it is not actually destroyed for several more minutes.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@poor</PRE>

<P>Resets all players' credits to 0.

<BR></P>

<P>MUSE only.

<BR></P>

<P><B>Wizards and Officials only.</B>

<BR></P>

<PRE>@powers <I>player</I>|<I>thing</I></PRE>

<P>Lists the authorized powers of the player or thing.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@protect <I>object</I></PRE>

<P>Sets the @doomsday attribute on the object to -1, in order to keep the object from being destroyed with @destroy.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@ps</PRE>

<P>Lists the queued commands that have not yet been executed.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@quota</PRE>

<P>Displays your current builders' quota.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@quota *<I>player</I>=<I>#quota-amount</I></PRE>

<P>Resets the player's builders' quota to the specified quota amount.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<P><B>Wizards and Officials only.</B>

<BR></P>

<PRE>@recycle <I>object</I></PRE>

<P>Recycles the object, which saves space in the database. Remember your cyber-ecology!

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@relink <I>exit</I>=<I>#room</I></PRE>

<P>Relinks the exit to a different room number.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@remit <I>object</I>=<I>message</I></PRE>

<P>Emits the message to the contents of the object. The object is generally a room.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@runout <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions triggered when the object's charges reach 0.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@rwho start|stop|status</PRE>

<P>Starts, stops and shows the status of the RWHO server. When stopped, the RWHO command will not operate.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@search [<I>player</I>] [<I>class</I>=<I>restrictions</I>]</PRE>

<P>Searches the mud database and lists the objects that meet the player's search criteria. If the player argument is supplied, only objects owned by that player are listed. If the class argument is supplied, only objects of a certain class are listed. 
Costs 10 credits. The command @search flags=RHD lists all rooms (the R flag) set HAVEN and DARK (the R and H flags). The command @search type=rooms lists all rooms owned by the player.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@searchobj <I>object</I>=<I>text</I></PRE>

<P>Searches an entire object and its attributes for the specified text. It then lists out each matching attribute. You may include wild card characters.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@selfboot</PRE>

<P>Automatically performs an @boot on you three times, to clear up double logins into the mud. This means that you and your doubles (only) will be disconnected. Afterwards, you can reconnect to the mud.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@set</PRE>

<P>Used to set attributes and flags on objects. May be used in various ways:

<BR></P>

<PRE>@set <I>object</I>=<I>flag</I></PRE>

<P>Sets the specified flag on the object.

<BR></P>

<PRE>@set <I>object</I>=! <I>flag</I></PRE>

<P>Resets the specified flag on the object.

<BR></P>

<PRE>@set <I>object</I>=<I>attribute</I>:<I>value</I></PRE>

<P>Sets an attribute value on the object.

<BR></P>

<PRE>@set <I>object</I>=! <I>attribute</I>:<I>value</I></PRE>

<P>Resets an attribute value on the object.

<BR></P>

<PRE>@<I>attribute</I> <I>object</I>=<I>value</I></PRE>

<P>Short form of: @set object attribute:value.

<BR></P>

<PRE>@<I>new-attribute</I> <I>new-object</I>=<I>old-object</I>/<I>old-attribute</I></PRE>

<P>Copies an attribute from one object to another object.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@sex <I>player</I>=<I>gender</I></PRE>

<P>Sets the gender of the player. The player's gender is used for pronoun substitution. Options: unassigned, male, female, neuter, spivak, plural. The default is unassigned. Pronouns<I> </I>cannot be used in reference to players unless their gender is set 
to one of these choices. Visible to all.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@sfail <I>room</I>=<I>message</I></PRE>

<P>Sets the message shown only to the player who fails to use the @slock. The player's name is not prefixed to the message.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@shutdown</PRE>

<P>Shuts down the mud.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<P><B>Wizards and Officials only.</B>

<BR></P>

<PRE>@slock <I>room</I>=<I>arguments</I></PRE>

<P>Speech lock. Sets the speech lock on the room, where only the players specified in the arguments may speak in the room. The owner may talk in the room, and those with the power to spoof, even if they are not on the list. This command only affects rooms. 
The room that the @slock is on must be set AUDITORIUM: @set room=A.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@startup <I>object</I>=<I>actions</I></PRE>

<P>Sets the actions to be performed in the event that the mud crashes and gets rebooted. By using @startup, you can retrigger objects that need to be running continuously.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@stats [<I>player</I>]</PRE>

<P>Displays all the objects in the game broken down by types.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<P><B>Officials can supply a player name to count only objects owned by that </B><B>player.</B>

<BR></P>

<PRE>@success <I>object</I>[=<I>message</I>]</PRE>

<P>Sets the success message for the specified object, which is displayed to the player whenever a player successfully uses the object. Without a message, it clears any existing message. Abbr.: @succ.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<PRE>@sweep</PRE>

<P>Lists all the objects and players that are listening in the room you are currently in, as well as in the objects you are carrying. In these listings, player denotes a connected player that hears all occurrences in the room, puppet denotes a puppet 
belonging to a connected player, relaying all occurrences in the room to the owner, messages denotes an object that is listening for specific occurrences in the room, and commands denotes an object waiting for a specific command.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@switch</PRE>

<P>Evaluates a conditional expression and performs different actions based on the results of that evaluation. May be used in two ways:

<BR></P>

<PRE>@switch <I>condition</I>={<I>pattern1</I>},{<I>yes-actions</I>},{<I>no-actions</I>}</PRE>

<P>Corresponds to the IF-THEN-ELSE programming structure.

<BR></P>

<PRE>@switch <I>condition</I>={<I>pattern1</I>},{<I>yes-actions1</I>},{<I>pattern2</I>},{<I>yes-actions2</I>},...,{<I>default-actions</I>}</PRE>

<P>Corresponds to the CASE or SWITCH programming structure.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@teleport <I>thing</I>=<I>#room</I>

@teleport <I>#room</I></PRE>

<P>Teleports the given thing to the specified room. If the thing is omitted, the command teleports you to the specified room. You must own or control the thing or its current location. You can only teleport objects into rooms or objects you own or that are 
set JUMP_OK. If the target room has a drop-to, the object will go to the drop-to room instead. Abbr.: @tel.

<BR></P>

<P>Available on MUCK, MUSH, and MUSE.

<BR></P>

<P><B>Officials can teleport objects into players' inventories.</B>

<BR></P>

<PRE>@trigger</PRE>

<P>Passes control and data (on the stack) between items. If you create attributes that are triggered by other commands or actions, this command can be used to trigger them. Many tricky things can be done with simple command combinations. Abbr.: @tr.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@tz <I>player</I>|<I>object</I>=<I>#hours</I>:y|n</PRE>

<P>Sets a player's time zone. The #hours is a numerical value representing the number of hours the player's time is ahead of or behind Greenwich Mean Time (GMT) (also referred to as Universal Coordinated Time (UTC), or London Time). The y or n refers to 
whether or not U.S. style Daylight Savings Time is used in your area. Objects that do not have a @tz set on them will use their owner's @tz. However, a player may set the @tz register on any object individually. If neither the object nor the object's owner 
has a @tz set, the mud will default to the local time at the mud's server site.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@ufail <I>object</I>=<I>actions</I></PRE>

<P>Sets the message shown to a player who fails to use an object due to an @ulock.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@ulock <I>object</I>=<I>lock</I></PRE>

<P>Sets the Use Lock for the object. Only players or things satisfying the lock will be able to trigger $ and ! events on the object.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@undefattr <I>object</I>/<I>attribute</I></PRE>

<P>Removes the specified attribute definition<I> </I>from the object, if it was set with @defattr. If object has children with the attribute, they lose the definition and any stored values, so use this command with great caution.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@undestroy object</PRE>

<P>Aborts an @destroy process on the object if entered within 5-10 minutes of the original @destroy command.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@unhide</PRE>

<P>Restores your name in the WHO list. Players are reset to @unhide each time they connect.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@unprotect <I>object</I></PRE>

<P>Removes the @doomsday attribute on the object, allowing it to be @destroyed.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@unlink <I>exit</I>

@unlink here</PRE>

<P>Removes links from exits. The first version shown removes a link from the specified exit. The second removes the drop-to on the room. Be careful, though; anyone can relink an unlinked exit, thereby becoming its new owner (you will, however, be 
reimbursed for your 1 credit).

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@unlock <I>object</I></PRE>

<P>Removes the lock on the object.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@va <I>object</I>=<I>actions</I>

@vb <I>object</I>=<I>actions</I>

     .

     .

     .

@vz <I>object</I>=<I>actions</I></PRE>

<P>Sets the v-register on the object to the specified actions. Every object has 26 built-in registers, va through vz. Anything may be stored on a v-register. If a v-register contains a semicolon-separated list of actions (for example, @va 
<I>object</I>=<I>action1</I>;<I>action2</I>;<I>action3</I>), these actions will be executed in order when the register is triggered.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@wait <I>#seconds</I>=<I>actions</I></PRE>

<P>Queues actions. The actions are placed on the queue and are executed no earlier than #seconds from the time it is queued. The actions may be a list of commands in curly braces.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>@whereis <I>player</I></PRE>

<P>Displays the location of the specified player. If you want to remain unlocatable, set yourself DARK. The located player receives a message informing him or her that you have successfully or unsuccessfully located them.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@who_flags <I>object</I>=<I>flags</I></PRE>

<P>Controls the output of WHO commands. Capital letters indicate &quot;full&quot; output; lowercase letters indicate &quot;truncated&quot; output:

<BR></P>

<PRE>A, a = Alias

C, c = Class

F, f = Flags (h: hidden, H: haven, N: set NO_WALLS)

I, i = IdleTime

N, n = Name

O, o = OnTime

H, h = Hostname.</PRE>

<P>The default is NfoiC.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@who_names <I>list-of-names</I></PRE>

<P>Restricts the WHO search and display to the specified names.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>@wipeout <I>player</I></PRE>

<P>Destroys all the player's possessions.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<P><B>Wizards and Officials only.</B>

<BR></P>

<H4><A ID="I124" NAME="I124">

<FONT SIZE=3><B>Flag Reference</B>

<BR></FONT></A></H4>

<P>In the mud, you can change the states, qualities, or abilities of other objects. Although many of these states can be mimicked at textual levels (by the creation of triggered text strings, for example), many are so far-reaching in importance that they 
have been removed to the level of <I>flags</I>. Flags may be thought of as switches on the object, which may be set in one direction or the other. The on position is indicated by the appearance of the flag's associated letter in the object's DBREF. The 
flag is off if the flag's letter doesn't appear.

<BR></P>

<P>All flags may be set and unset in the same way:

<BR></P>

<PRE>@set object=&lt;flag&gt;</PRE>

<P>Sets the flag.

<BR></P>

<PRE>@set object=!&lt;flag&gt; to reset (unset)</PRE>

<P>Resets, or unsets, the flag.

<BR></P>

<H4><A ID="I125" NAME="I125">

<FONT SIZE=3><B>Flags</B>

<BR></FONT></A></H4>

<PRE>Abode

Flag:  A

@set here=ABODE</PRE>

<P>Allows players to set their homes to that location. Players can also set object's homes to that location.

<BR></P>

<P>MUCK only.

<BR></P>

<PRE>Bearing

Flag:  b

@set <I>object</I>=BEARING</PRE>

<P>Allows players to @addparent or @delparent their objects to or from the specified object. If not set, the specified object can neither bear new children nor lose old ones.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>Builder

Flag:  B</PRE>

<P>On some muds, only players that have this flag set are allowed to build anything.

<BR></P>

<PRE>Change Ownership Allowed

Flag:  C

@set <I>object</I>=CHOWN_OK</PRE>

<P>Allows players to transfer ownership of the specified object to another player. To set it, you must be carrying the object. To set this flag on a room or exit, you must be in the room. Once set, the new player may gain ownership of object by using 
@chown.

<BR></P>

<P>Available in MUCK, MUSH, and MUSE.

<BR></P>

<PRE>Connected

Flag:  c

@set <I>player</I>=CONNECTED</PRE>

<P>Shows whether player is connected or not. This flag only applies to players.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>Dark

Flag:  D

@set <I>object</I>=DARK</PRE>

<P>Sets the object Dark. If a room is DARK, a look sees the room's description, but does not display the objects that the room contains. If a thing is DARK, look does not list that thing in the room's contents. Players who don't want to have their location 
found via @whereis may set themselves DARK. Puppets<I> </I>cannot be DARK, but an object set puppet and DARK enters &quot;debug&quot; mode, and relays to its owner everything it does and hears.

<BR></P>

<P>Available in MUCK, MUSH, and MUSE.

<BR></P>

<PRE>Destroyable

Flag:  d

@set <I>object</I>=DESTROY_OK</PRE>

<P>Allows any player to destroy the specified object as long as the object is not locked against them. This is good for creating things like notes, allowing the recipient to destroy the note after reading it, instead of having to look for you to destroy 
it.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>Enterable

Flag:  e

@set <I>object</I>=ENTER_OK</PRE>

<P>Allows players to enter the specified object. Players must be ENTER_OK if they want to be able to receive things from other players via the give command.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>Exit

Flag:  E</PRE>

<P>Available in MUCK, MUSH, and MUSE.

<BR></P>

<PRE>Floating

Flag:  f

@set <I>room</I>=FLOATING</PRE>

<P>When set on a disconnected room, this flag suppresses the disconnected room message. Should be used only by experienced builders because floating rooms can easily be forgotten or misplaced.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>Going

Flag:  G

@set <I>object</I>=GOING</PRE>

<P>Used internally; automatically set on objects that are @destroyed. If you change your mind about @destroying an object, use @undestroy to unset it quickly!

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>Haven

Flag:  H

@set <I>object</I>=HAVEN</PRE>

<P>Sets the object to be a haven. A haven player ignores all messages from other players. A haven object is halted, and its register commands is not triggered. If a room is a haven, you cannot kill in that room.

<BR></P>

<P>Available in MUCK, MUSH, and MUSE.

<BR></P>

<PRE>Hide

Flag:  h

@set <I>object</I>=HIDE</PRE>

<P>Used to mark players who do not want their names to show up on the WHO<I> </I>list. Set by @hide and reset by @unhide.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>Inherit

Flag:  I

@set <I>object</I>=INHERIT</PRE>

<P>Causes the object to inherit any special powers of its owner. Otherwise, the object has no special powers.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>Jump Allowed

Flag:  J

@set <I>room</I>=JUMP_OK</PRE>

<P>Allows players to @teleport into the room.

<BR></P>

<P>Available in MUCK, MUSH, and MUSE.

<BR></P>

<PRE>Key

Flag:  K

@set <I>object</I>=KEY</PRE>

<P>Sets the object to be a key. Puppets may not take the object, and the object returns to its home when its holder teleports away (except that the owner of the object can teleport with it).

<BR></P>

<P>Available in MUCK, MUSH, and MUSE.

<BR></P>

<PRE>Light

Flag:  l

@set <I>object</I>=LIGHT</PRE>

<P>Allows the object to be seen in a room that is set DARK.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>Link Allowed

Flag:  L

@set <I>object</I>=LINK_OK</PRE>

<P>Allows anyone to link exits <I>to</I> the object (but not <I>from </I>it). Anyone can also set the object as their home.

<BR></P>

<P>Available in MUCK, MUSH, and MUSE.

<BR></P>

<PRE>Mucker

Flag:  M

@set <I>object</I>=MUCKER</PRE>

<P>When set on a player, it allows the player to create MUF programs in MUCK.

<BR></P>

<P>Available in MUCK.

<BR></P>

<P><B>Wizards only.</B>

<BR></P>

<PRE>Opaque

Flag:  o

@set <I>player</I>=OPAQUE</PRE>

<P>Prevents other players from seeing what you are carrying in your inventory. Players can still see objects you are carrying that they own.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>Player

Flag:  P</PRE>

<P>Available in MUCK, MUSH, and MUSE.

<BR></P>

<PRE>Puppet

Flag:  p

@set <I>object</I>=puppet</PRE>

<P>Causes the object to grow eyes and ears; the object will relay all it sees and hears to its owner.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>Quiet

Flag:  q

@set me=QUIET</PRE>

<P>Blocks out all the set and triggered messages that you get when your objects are set or triggered. This is useful if you have a lot of machines running continuously. It will also keep you from hearing shake and crumble and deposit back messages when you 
destroy objects.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>Room

Flag:  R

@set <I>object</I>=room</PRE>

<P>Identifies the object as a room; automatically set when you @dig the room. Once set, it cannot be changed.

<BR></P>

<P>Available in MUCK, MUSH, and MUSE.

<BR></P>

<PRE>Slave

Flag:  s

@set <I>player</I>=SLAVE</PRE>

<P>Disables the player from doing anything except to pose; player cannot talk, page, build, get, or drop objects.

<BR></P>

<P>MUSE only.

<BR></P>

<P><B>Officials only.</B>

<BR></P>

<PRE>Sticky

Flag:  S

@set <I>object</I>=STICKY</PRE>

<P>Sets an object or room to be sticky. A thing that is sticky goes home when dropped. On room that is sticky, the drop-to is delayed until the last person leaves.

<BR></P>

<P>Available in MUCK, MUSH, and MUSE.

<BR></P>

<PRE>Terse

Flag:  t

@set <I>object</I>=TERSE</PRE>

<P>Sets an object or player to be terse. An object will not shake and crumble when destroyed. On a player, room descriptions won't be displayed when the player enters a new room (contents and exits are still displayed). This is good when you want to move 
about quickly, or don't want to read the room description. Beware: You might miss important information in some descriptions.

<BR></P>

<P>MUSH and MUSE only.

<BR></P>

<PRE>Transparent

Flag:  T

@set <I>exit</I>=TRANSPARENT</PRE>

<P>Allows players to look through the exit: they will first see the exit's description, followed by the description and contents of the room on the other side.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>Vehicle

Flag:  V

@set object=vehicle</PRE>

<P>Allows an object to contain players. Vehicles have certain restrictions placed on them, to prevent players from using vehicles to get around locks or go places they shouldn't.

<BR></P>

<P>Available in MUCK.

<BR></P>

<PRE>Visible

Flag:  v

@set <I>object</I>=VISIBLE</PRE>

<P>Allows any player to examine the object and see all the object's attributes as if they owned it. They cannot make any changes to object.

<BR></P>

<P>MUSE only.

<BR></P>

<PRE>Visual

Flag:  v

@set <I>object</I>=VISUAL</PRE>

<P>Allows any player to examine the object and see all the object's attributes as if they owned it. They cannot make any changes to object.

<BR></P>

<P>MUSH only.

<BR></P>

<PRE>Wizard

Flag:  W</PRE>

<P>Denotes a player that is a wizard. Wizards cannot be killed. They can use special wizard commands, and they are not subject to the same restrictions as normal players.

<BR></P>

<P>Available in MUCK, MUSH, and MUSE.

<BR></P>

<PRE>Zombie

Flag:  Z

@set object=zombie</PRE>

<P>Allows objects in MUCK to have the @force and the FORCE MUF primitive used on them.

<BR></P>

<P>Available in MUCK.

<BR></P>

<H3><A ID="I126" NAME="I126">

<FONT SIZE=4><B>Attribute Options Reference</B>

<BR></FONT></A></H3>

<P>Mud objects have attributes, which are registers in which you can place text or commands. The basic and at-commands generally impact directly upon one or more of the built-in attributes, such as @succ, @osucc, @asucc, and so forth. The @defattr command 
can be used to create entirely new attributes.

<BR></P>

<P>But there is still another level of mud code we can explore! A broad set of functional modifiers known as <I>attribute options </I>may be applied to @defattr commands. These options allow you to change how your objects' attributes respond to their 
environments in subtle and far-reaching ways.

<BR></P>

<P>To create or modify a user-defined attribute and/or install an option, type:

<BR></P>

<PRE>@defattr <I>object</I>/<I>attribute</I>=<I>attribute-option</I></PRE>

<P>Some of these attribute options are only available on MUSEs.

<BR></P>

<H4><A ID="I127" NAME="I127">

<FONT SIZE=3><B>Attribute Options</B>

<BR></FONT></A></H4>

<PRE>Dark</PRE>

<P>A dark attribute is not visible in an examine command, and cannot be obtained by a get function.

<BR></P>

<PRE>Date</PRE>

<P>A date attribute stores date and time information, if the information is entered in xtime() format. Anyone who examines the object will see the correct date and time for their own timezone.

<BR></P>

<PRE>Function</PRE>

<P>A function attribute can create a user-defined function. You can enter any text or function into the attribute register, and it is executed whenever someone attempts to call the function (the function must first be defined on the object). For example, 
assume the object named testobj has already been created. You can define functions on it as follows:

<BR></P>

<PRE>&gt; @defattr testobj/mult60=function inherit

Set.

&gt; @mult60 blee=[mul(60,v(0))]

Set.

&gt; say [mult60(3)]

180

&gt; @defattr testobj/foo=function inherit

Set.

&gt; @foo testobj=Everyone with [v(0)]: go to the [v(1)]!

Set.

&gt; say [foo(coats,closet)]

You say &quot;Everyone with coats: go to the closet!&quot;

Inherit</PRE>

<P>An inherit attribute will pass its value down from parent to child. Child objects may have these values overwritten, but if these new values are erased, the original inherited value will appear again. This option is set on most of the built-in 
attributes.

<BR></P>

<PRE>Osee</PRE>

<P>An osee attribute can be seen by anyone who examines an object on which the attribute has a value, even if the object is not set to be visible. Attributes with a built-in osee option include last, sex, and race.

<BR></P>

<PRE>Unsaved</PRE>

<P>An unsaved attribute will not retain its contents when the mud is rebooted. The IT attribute carries the unsaved option.

<BR></P>

<PRE>Wizard</PRE>

<P>A wizard attribute can be @set only by the object's owner (or by a Wizard or Official). If you define an attribute with the wizard and inherit options, its child objects may be given to other players&#151;even allowing other players to @chown 
them&#151;and the new owners will not be able to change that attribute.

<BR></P>

<H4><A ID="I128" NAME="I128">

<FONT SIZE=3><B>MUF Function Reference</B>

<BR></FONT></A></H4>

<P>This section describes the functions available for use in the MUF programming language (used on MUCKs). It is based on the MUF Reference Manual.

<BR></P>

<H4><A ID="I129" NAME="I129">

<FONT SIZE=3><B>Notation</B>

<BR></FONT></A></H4>

<P>A special function notation is used to denote the values used on the stack, and any variables that are pushed back onto the stack. The notation

<BR></P>

<PRE><I>function</I>(<I>value1</I> <I>value2</I> | <I>result</I>)</PRE>

<P>means that the given function first pops <I>value2</I> from the top of the stack and then pops <I>value1</I> from the stack. It then processes these values in some fashion and produces a result. This <I>result</I> is then pushed onto the stack. The 
value pushed onto the stack is denoted by the item following the vertical bar, if any. Usng this syntax, the addition function would be:

<BR></P>

<PRE>+ (<I>integer1</I> <I>integer2 </I>| <I>sum</I>)</PRE>

<P>A function that does not put anything back onto the stack will not have anything after the vertical bar:

<BR></P>

<PRE>pop (<I>val</I> |)</PRE>

<H4><A ID="I130" NAME="I130">

<FONT SIZE=3><B>Parameter Types</B>

<BR></FONT></A></H4>

<P>Throughout this section, the following terminology is used to indicate parameter types:

<BR></P>

<TABLE BORDER>

<TR>

<TD>

<PRE><B><I>Terminology</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Indicates</I></B>

<BR></PRE>

<TR>

<TD>

<P>int</P>

<TD>

<P>integer</P>

<TR>

<TD>

<P>str</P>

<TD>

<P>string</P>

<TR>

<TD>

<P>dbref</P>

<TD>

<P>DBREF</P>

<TR>

<TD>

<P>var</P>

<TD>

<P>variable</P>

<TR>

<TD>

<P>boolean</P>

<TD>

<P>either 0 or 1</P>

<TR>

<TD>

<P>value</P>

<TD>

<P>any value</P>

<TR>

<TD>

<P>result</P>

<TD>

<P>any value</P></TABLE>

<H3><A ID="I131" NAME="I131">

<FONT SIZE=4><B>MUF Functions</B>

<BR></FONT></A></H3>

<H4><A ID="I132" NAME="I132">

<FONT SIZE=3><B>Arithmetic Functions</B>

<BR></FONT></A></H4>

<P>The following functions are available for arithmetic:

<BR></P>

<TABLE BORDER>

<TR>

<TD>

<PRE><B><I>Function</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Description</I></B>

<BR></PRE>

<TR>

<TD>

<P>+ (<I>int1</I> <I>int2</I> | <I>sum</I>)</P>

<TD>

<P>Adds int1 to int2</P>

<TR>

<TD>

<P>- (<I>int1</I> <I>int2</I> | <I>difference</I>)</P>

<TD>

<P>Subtracts int2 from int1</P>

<TR>

<TD>

<P>* (<I>int1</I> <I>int2</I> | <I>product</I>)</P>

<TD>

<P>Multiplies int1 by int2</P>

<TR>

<TD>

<P>/ (<I>int1</I> <I>int2</I> | <I>integer-result</I>)</P>

<TD>

<P>Integer-divides int2 by int1</P>

<TR>

<TD>

<P>% (<I>int1</I> <I>int2</I> | <I>remainder</I>)</P>

<TD>

<P>Modulo of int2 divided by int1</P></TABLE>

<H4><A ID="I133" NAME="I133">

<FONT SIZE=3><B>Comparison Functions</B>

<BR></FONT></A></H4>

<P>The following functions are available for comparison. They push a boolean result of either 0 or 1 back onto the stack.

<BR></P>

<TABLE BORDER>

<TR>

<TD>

<PRE><B><I>Function</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Description</I></B>

<BR></PRE>

<TR>

<TD>

<P>&lt;  (<I>int1</I> <I>int2</I> | <I>boolean</I>)</P>

<TD>

<P>Less than</P>

<TR>

<TD>

<P>&lt;= (<I>int1</I> <I>int2</I> | <I>boolean</I>)</P>

<TD>

<P>Less than or equal to</P>

<TR>

<TD>

<P>&gt;  (<I>int1</I> <I>int2</I> | <I>boolean</I>)</P>

<TD>

<P>Greater than</P>

<TR>

<TD>

<P>&gt;= (<I>int1</I> <I>int2</I> | <I>boolean</I>)</P>

<TD>

<P>Greater than or equal to</P>

<TR>

<TD>

<P>=  (<I>int1</I> <I>int2</I> | <I>boolean</I>)</P>

<TD>

<P>Equal to</P></TABLE>

<PRE>@ (<I>var</I> | <I>value</I>)</PRE>

<P>Accesses var and places its value onto the stack.

<BR></P>

<PRE>! (<I>var</I> <I>value</I> | )</PRE>

<P>Places the given value into the variable var.

<BR></P>

<PRE>addprop(<I>item-dbref property-str property-value-str int</I>| )</PRE>

<P>Sets the given property on the given item. The property is set to the given property value. If this string is null, the property is set to the given integer. All four parameters to this function must be on the stack (for example, you cannot omit certain 
ones).

<BR></P>

<P>and(<I>value1</I> <I>value2</I> | <I>boolean</I>)

<BR></P>

<P>Performs Boolean AND on value1 and value2 and pushes the Boolean result.

<BR></P>

<PRE>atoi(<I>str</I> | <I>int</I>)</PRE>

<P>Converts a string into an integer. If the string is not a number, 0 is pushed onto the stack.

<BR></P>

<PRE>call(<I>program-name</I>)</PRE>

<P>Starts executing a different MUF program. The program must have been compiled already. The called program inherits the value of me, loc, and trigger.

<BR></P>

<PRE>contents(<I>container-dbref</I> | <I>first-item-dbref</I>)</PRE>

<P>Pushes the DBREF of the first item contained in the container onto the stack. You could then use the next function to scan through the rest of the items in the container.

<BR></P>

<PRE>copyobj(<I>original-dbref</I> | <I>copy-dbref</I>)</PRE>

<P>Creates a copy of the original thing and pushes the copy's DBREF onto the stack.

<BR></P>

<PRE>dbcmp(<I>dbref1 dbref2</I> | <I>boolean</I>)</PRE>

<P>Compares two DBREFs and pushes the Boolean result.

<BR></P>

<PRE>dbref(<I>int</I> | <I>dbref</I>)</PRE>

<P>Changes the integer into a DBREF. dbref(54) is the same as #54.

<BR></P>

<PRE>desc(<I>item-dbref</I> | <I>desc-str</I>)</PRE>

<P>Pushes the description attribute (@desc) of the item onto the stack.

<BR></P>

<PRE>drop(<I>item-dbref</I> | <I>drop-str</I>)</PRE>

<P>Pushes the drop attribute (@drop) of the item onto the stack.

<BR></P>

<PRE>dup(<I>val</I> | <I>val</I> <I>val</I>)</PRE>

<P>Duplicates the top of the stack.

<BR></P>

<PRE>exit</PRE>

<P>Exits from the MUF word being executed.

<BR></P>

<PRE>exit?(<I>dbref</I> | <I>boolean</I>)</PRE>

<P>Checks if the item is an exit object, and pushes the Boolean result.

<BR></P>

<PRE>exits(<I>item-dbref</I> | <I>exit-dbref</I>)</PRE>

<P>Pushes the DBREF of the first exit object in the exit list of the given item onto the stack. You could then use the next function to scan through the rest of the exits in the exit list.

<BR></P>

<PRE>explode(<I>str1</I> <I>str2</I> | <I>str1</I> ... <I>strN</I> <I>int</I>)</PRE>

<P>Breaks str1 into individual strings, delimited by the delimiter in str2. The individual strings are pushed in reverse order onto the stack, and then an integer indicating the number of individual strings is pushed onto the stack. For example, if str1 
was &quot;This is a test&quot; and str2 was a space character, &quot; &quot;, the stack would be &quot;test&quot; &quot;a&quot; &quot;is&quot; &quot;This&quot; 4, after this function. The null string, &quot;&quot;, cannot be used as str2.

<BR></P>

<PRE>fail(<I>item-dbref</I> | <I>fail-str</I>)</PRE>

<P>Pushes the fail attribute (@fail) of the item onto the stack.

<BR></P>

<PRE>flag?(<I>item-dbref str</I> | <I>boolean</I>)</PRE>

<P>Uses the given string parameter as the name of a flag to check if the given flag is on or off for the item. Pushes 1 if it is on and 0 if it is off.

<BR></P>

<PRE>getlink(<I>item-dbref</I> | <I>link-dbref</I>)</PRE>

<P>Pushes whatever the item is linked to onto the stack. If the item is an exit, it pushes whatever the item is linked to. If the item is a player, it pushes the DBREF of the player's home. If the item is a room, it pushes the room's drop-to, if any. If 
the item is not linked to anything, #-1 is pushed.

<BR></P>

<PRE>getpropstr(<I>item-dbref</I> <I>prop-name-str</I> | <I>prop-str</I>)</PRE>

<P>Looks up the property named <I>prop-name-str</I> in the item, and pushes the string corresponding to that property. Pushes the null string if the property does not have a value.

<BR></P>

<PRE>getpropval(<I>item-dbref prop-name-str</I> | <I>prop-int</I>)</PRE>

<P>Looks up the property named <I>prop-name-str</I> in the item, and pushes the integer corresponding to that property. Pushes 0 if the property does not have a value.

<BR></P>

<PRE>if (<I>boolean</I>) <I>statements</I> [ else <I>statements</I> ] then</PRE>

<P>Tests the Boolean value. If the value is true, the statements after the if, up until the next then (or the next else, if the else is present), are executed. If the value is false, the statements between the else and next are executed. Execution then 
resumes after the word then. The if statement pops the Boolean value from the stack. As a helpful hint, it may be better to think of the then keyword as an endif.

<BR></P>

<PRE>instr(<I>source-str pattern-str</I> | <I>index-int</I>)</PRE>

<P>Searches for the pattern string in the source string. Pushes the index of the first occurance of the pattern in the source, or -1 if the pattern is not found.

<BR></P>

<PRE>int(<I>item</I> | <I>int</I>)</PRE>

<P>Converts the variable item or object item into an integer.

<BR></P>

<PRE>intostr(<I>int</I> | <I>str</I>)</PRE>

<P>Converts an integer into a string. The integer could also be a DBREF.

<BR></P>

<PRE>location(<I>item-dbref</I> | <I>location-dbref</I>)</PRE>

<P>Pushes the DBREF of the location of the given item onto the stack.

<BR></P>

<PRE>match(<I>str</I> | <I>item-dbref</I>)</PRE>

<P>Checks the given string against the player's objects, the objects in the room, and the exits in the room. Pushes the first object that contains the given string onto the stack. Pushes #-1 if the string is not matched in any object.

<BR></P>

<PRE>moveto(<I>item-dbref location-dbref</I> | )</PRE>

<P>Moves the item to the given location.

<BR></P>

<PRE>name(<I>item-dbref</I> | <I>name-str</I>)</PRE>

<P>Pushes the name attribute (@name) of the given item onto the stack.

<BR></P>

<PRE>next(<I>item-dbref</I> | <I>next-item-dbref</I>)</PRE>

<P>Pops the given item and pushes the next item in the list of contents (if the item is an obect) or list of exits (if the item is an exit) onto the stack.

<BR></P>

<PRE>not(<I>value</I> | <I>boolean</I>)</PRE>

<P>Performs the Boolean NOT on the value, and pushes 1 if the value evaluates true and 0 if the value evaluates false.

<BR></P>

<PRE>notify(<I>player-dbref message-str</I> | )</PRE>

<P>Sends the given string to the given player.

<BR></P>

<PRE>notify_except(<I>room-dbref player-dbref message-str</I> | )</PRE>

<P>Sends the given message to everyone in the given room except for the specified player. The excepted player can be #-1, in which case the message is sent to everyone in the room.

<BR></P>

<PRE>number?(<I>str</I> | <I>boolean</I>)</PRE>

<P>Pushes 1 if the string consists of a number, 0 otherwise.

<BR></P>

<PRE>odrop(<I>item-dbref</I> | <I>odrop-str</I>)</PRE>

<P>Pushes the odrop attribute (@odrop) of the item onto the stack.

<BR></P>

<PRE>ofail(<I>item-dbref</I> | <I>ofail-str</I>)</PRE>

<P>Pushes the ofail attribute (@ofail) of the item onto the stack.

<BR></P>

<PRE>ok?(<I>value</I> | <I>boolean</I>)</PRE>

<P>Pushes 1 if the value is a valid object, 0 otherwise.

<BR></P>

<PRE>or(<I>value1</I> <I>value2</I> | <I>boolean</I>)</PRE>

<P>Performs Boolean OR on value1 and value2 and pushes the Boolean result.

<BR></P>

<PRE>osucc(<I>item-dbref</I> | <I>osucc-str</I>)</PRE>

<P>Pushes the osucc attribute (@osucc) of the item onto the stack.

<BR></P>

<PRE>over(<I>value</I> <I>other-value</I> | <I>value</I> <I>other-value value</I>)</PRE>

<P>Copies the second-to-top value on the stack.

<BR></P>

<PRE>owner(<I>item-dbref</I> | <I>owner-dbref</I>)</PRE>

<P>Pushes the DBREF of the owner of the specified item onto the stack.

<BR></P>

<PRE>pick(<I>value1</I> ... <I>valueN</I> <I>ith-int</I> | <I>value1</I> ... <I>valueN ith-value</I>)</PRE>

<P>Copies the ith value from the top of the stack and pushes it onto the stack.

<BR></P>

<PRE>player?(<I>item-dbref</I> | <I>boolean</I>)</PRE>

<P>Pushes 1 if the item is a player, 0 otherwise.

<BR></P>

<PRE>pop(<I>value</I> | )</PRE>

<P>Pops the top of the stack.

<BR></P>

<PRE>program?(<I>item-dbref</I> | <I>boolean</I>)</PRE>

<P>Pushes 1 if the item is a program, 0 otherwise.

<BR></P>

<PRE>pronoun_sub(<I>item-dbref str</I> | <I>new-str</I>)</PRE>

<P>Uses the given item to convert pronoun substitutions (%n, %p, %o, and so forth) in the given string to the pronouns corresponding to the item. The new string is then pushed onto the stack.

<BR></P>

<PRE>random( | <I>int</I>)</PRE>

<P>Pushes a random integer from 0 to MAXINT onto the stack.

<BR></P>

<PRE>read( | <I>str</I>)</PRE>

<P>Reads a string from the user and pushes it onto the stack.

<BR></P>

<PRE>remove_prop(<I>item_dbref property-str</I> | )</PRE>

<P>Removes the given property from the given item.

<BR></P>

<PRE>rinstr(<I>source-str pattern-str</I> | <I>index-int</I>)</PRE>

<P>Searches for the pattern string in the source string. Pushes the index of the last occurance of the pattern in the source, or -1 if the pattern is not found.

<BR></P>

<PRE>rmatch(<I>item-dbref str</I> | <I>item-dbref</I>)</PRE>

<P>Checks the given string against all the objects associated with the given item. Pushes the object that matches the given string onto the stack. Pushes #-1 if no object matches the string.

<BR></P>

<PRE>room?(<I>item-dbref</I> | <I>boolean</I>)</PRE>

<P>Pushes 1 if the item is a room, 0 otherwise.

<BR></P>

<PRE>rotate(<I>value-i value-i+1 ... valueN ith-int</I> | <I>value-i+1 ... valueN value-i</I>)</PRE>

<P>Moves the ith value to the top of the stack.

<BR></P>

<PRE>set(<I>item-dbref flag-str</I> | )</PRE>

<P>Turns on the given flag on the given item.

<BR></P>

<PRE>setdesc(<I>item-dbref str</I> | )</PRE>

<P>Sets the description attribute (@desc) of the given item to the given string.

<BR></P>

<PRE>setdrop(<I>item-dbref str</I> | )</PRE>

<P>Sets the drop attribute (@drop) of the given item to the given string.

<BR></P>

<PRE>setfail(<I>item-dbref str</I> | )</PRE>

<P>Sets the fail attribute (@fail) of the given item to the given string.

<BR></P>

<PRE>setname(<I>item-dbref str</I> | )</PRE>

<P>Sets the name attribute (@name) of the given item to the given string.

<BR></P>

<PRE>setodrop(<I>item-dbref str</I> | )</PRE>

<P>Sets the odrop attribute (@odrop) of the given item to the given string.

<BR></P>

<PRE>setofail(<I>item-dbref str</I> | )</PRE>

<P>Sets the ofail attribute (@ofail) of the given item to the given string.

<BR></P>

<PRE>setosucc(<I>item-dbref str</I> | )</PRE>

<P>Sets the osucc attribute (@osucc) of the given item to the given string.

<BR></P>

<PRE>setsucc(<I>item-dbref str</I> | )</PRE>

<P>Sets the succ attribute (@succ) of the given item to the given string.

<BR></P>

<PRE>strcat(<I>str1 str2</I> | <I>str1str2</I>)</PRE>

<P>Concatenates the top two strings on the stack and pushes the result.

<BR></P>

<PRE>strcmp(<I>str1 str2</I> | <I>int</I>)</PRE>

<P>Pushes 0 if the two top strings are equal, or a non-zero number if they are not equal. Case-sensitive.

<BR></P>

<PRE>strcut(<I>source-str index-int</I> | <I>first-str second-str</I>)</PRE>

<P>Breaks the given source string into two parts, and pushes these two parts back onto the stack. The string is broken at the character after the given index integer. Example: information 6 strcut would push inform ation back onto the stack.

<BR></P>

<PRE>stringcmp(<I>str1 str2</I> | <I>int</I>)</PRE>

<P>Pushes 0 if the two top strings are equal, or a non-zero number if they are not equal. NOT case-sensitive.

<BR></P>

<PRE>strlen(<I>str</I> | <I>int</I>)</PRE>

<P>Pushes the length of the given string onto the stack.

<BR></P>

<PRE>strncmp(<I>str1 str2 numchars-int</I> | <I>int</I>)</PRE>

<P>Compares the first numchars characters of the two strings on the top of the stack. Pushes 0 if the two top strings are equal, or a non-zero number if they are not equal. Case-sensitive.

<BR></P>

<PRE>subst(<I>source-str pattern-str replacement-str</I> | <I>new-str</I>)</PRE>

<P>Takes the source string and changes all occurances of the pattern string to the given replacement string. The resulting new string is then pushed onto the stack.

<BR></P>

<PRE>succ(<I>item-dbref</I> | <I>succ-str</I>)</PRE>

<P>Pushes the succ attribute (@succ) of the item onto the stack.

<BR></P>

<PRE>swap(<I>value1 value2</I> | <I>value2 value1</I>)</PRE>

<P>Switches the two top values on the stack.

<BR></P>

<PRE>thing?(<I>item-dbref</I> | <I>boolean</I>)</PRE>

<P>Pushes 1 onto the stack if the item is a thing, otherwise pushes 0.

<BR></P>

<PRE>time( | <I>seconds-int minutes-int hours-int</I>)</PRE>

<P>Pushes the time onto the stack in the form of three integers representing the seconds, minutes, and hours at that current time.

<BR></P>

<PRE>variable(<I>int</I> | <I>variable</I>)</PRE>

<P>Converts the given integer into a variable. There are three predefined variables: me corresponds to variable number 0, loc is variable number 1, and trigger is variable number 2. Thus the code: 0 variable is equivalent to: me.

<BR></P>

<H3><A ID="I134" NAME="I134">

<FONT SIZE=4><B>MUSH and MUSE Function Reference</B>

<BR></FONT></A></H3>

<P>This section presents functions that are available for use in MUSH and MUSE programs.

<BR></P>

<P>A large number of intricate operations can be performed by mud objects, including many basic and advanced mathematical operations. You can access these operations by using <I>function calls</I>. Function calls can also be used to perform 
character-string and logical operations, and to generate information on the state of the database and its contents. They return their data almost instantly, allowing you to use it in your commands statements and action lists. By incorporating a few of 
these function calls in your objects, you can really create some impressive stuff.

<BR></P>

<H4><A ID="I135" NAME="I135">

<FONT SIZE=3><B>Functions</B>

<BR></FONT></A></H4>

<PRE>abs(<I>number</I>)</PRE>

<P>Returns the absolute value of the number.

<BR></P>

<PRE>add(<I>a</I>, <I>b</I>)</PRE>

<P>Returns the sum of a and b.

<BR></P>

<PRE>arccos(<I>number</I>)</PRE>

<P>Returns the arccosine of the number.

<BR></P>

<PRE>arcsin(<I>number</I>)</PRE>

<P>Returns the arcsine of the number.

<BR></P>

<PRE>arctan(<I>number</I>)</PRE>

<P>Returns the arctangent of the number.

<BR></P>

<PRE>art(<I>word</I>)</PRE>

<P>Returns the appropriate article of the following word; returns a if the initial letter of the next word is a consonant, and an if it's a vowel.

<BR></P>

<PRE>band(<I>a</I>, <I>b</I>)</PRE>

<P>Returns the bitwise AND of a and b (which are signed decimal integers).

<BR></P>

<PRE>base(<I>number</I>, <I>oldbase</I>, <I>newbase</I>)</PRE>

<P>Converts the number from the oldbase to the newbase. Bases must be between 2 and 36. Digits above 9 are represented by letters a = 10, through z = 35. For example, base(14,10,2) returns 111,. base(aa,16,10) returns 170.

<BR></P>

<PRE>bnot(<I>number</I>)</PRE>

<P>Returns the bitwise NOT of the number (which is a signed decimal integer)

<BR></P>

<PRE>bor(<I>a</I>, <I>b</I>)</PRE>

<P>Returns the bitwise OR of a and b (which are signed decimal integers).

<BR></P>

<PRE>bxor(<I>a</I>, <I>b</I>)</PRE>

<P>Returns the bitwise XOR of a and b (which are signed decimal integers).

<BR></P>

<PRE>change(<I>string1</I>, <I>string2</I>, <I>index</I>)</PRE>

<P>Changes the character at the given index in string1 to string2. Characters are numbered starting at 1.

<BR></P>

<PRE>children(<I>object</I>)</PRE>

<P>Returns a list of the object's children, in a format suitable for @foreach.

<BR></P>

<PRE>cjust(<I>string</I>, <I>width</I>)</PRE>

<P>Returns the string, center-justified, in a field of the given width.

<BR></P>

<PRE>comp(<I>n</I>, <I>m</I>)</PRE>

<P>Returns 0 if n = m, -1 if n &lt; m, and 1 if n &gt; m. Non-numeric strings all equal 0.

<BR></P>

<PRE>con(<I>object</I>)</PRE>

<P>Returns the first thing in the contents list of the object. Similar to the Lisp car() function.

<BR></P>

<PRE>cos(<I>number</I>)</PRE>

<P>Returns the cosine of the given number.

<BR></P>

<PRE>cr(<I>player</I>)</PRE>

<P>Returns the number of credits<I> </I>belonging to the player.

<BR></P>

<PRE>delete(<I>string</I>, <I>index</I>, <I>numchars</I>)</PRE>

<P>Returns the remainder of the given string after deleting numchars characters beginning with the character at the given index. Characters are numbered starting at 0.

<BR></P>

<PRE>dist2d(<I>x1</I>, <I>y1</I>, <I>x2</I>, <I>y2</I>)</PRE>

<P>Returns the distance between (x1, y1) and (x2, y2) as if plotted on a 2-dimensional graph.

<BR></P>

<PRE>dist3d(<I>x1</I>, <I>y1</I>, <I>z1</I>, <I>x2</I>, <I>y2</I>, <I>z2</I>)</PRE>

<P>Returns the distance between (x1, y1, z1) and (x2, y2, z2) as if plotted on a 3-dimensional graph.

<BR></P>

<PRE>div(<I>a</I>, <I>b</I>)</PRE>

<P>Returns a divided by b (this is integer division with no remainder).

<BR></P>

<PRE>entrances(<I>object</I>)</PRE>

<P>Returns a list of exits leading into the object, in a format suitable for use by @foreach.

<BR></P>

<PRE>even(<I>argument</I>)</PRE>

<P>Returns 1 if the argument is an even number, otherwise 0.

<BR></P>

<PRE>exit(<I>object</I>)</PRE>

<P>On a room, returns the first exit in the room. On a thing, returns its home.

<BR></P>

<PRE>exp(<I>number</I>)</PRE>

<P>Returns the number raised to the power of e (reverse ln).

<BR></P>

<PRE>extract(<I>string</I>, <I>wordnumber</I>, <I>numwords</I>)</PRE>

<P>Returns the substring from string starting at word number wordnumber and containing numwords words. Words are numbered starting at 1.

<BR></P>

<PRE>fadd(<I>a</I>, <I>b</I>)</PRE>

<P>Returns a + b, where a and b are floating point numbers.

<BR></P>

<PRE>fcomp(<I>a</I>, <I>b</I>)</PRE>

<P>Returns 0 if a = b, -1 if a &lt; b, and 1 if a &gt; b. Non-numeric strings equal 0.

<BR></P>

<PRE>fdiv(<I>a</I>, <I>b</I>)</PRE>

<P>Returns a / b, where a and b are floating point numbers.

<BR></P>

<PRE>first(<I>string</I>)</PRE>

<P>Returns the first word of the string.

<BR></P>

<PRE>flags(<I>object</I>)</PRE>

<P>Returns a string consisting of the current flags on the object.

<BR></P>

<PRE>flip(<I>string</I>)</PRE>

<P>Returns the string with its characters reversed.

<BR></P>

<PRE>fmul(<I>a</I>, <I>b</I>)</PRE>

<P>Returns a * b where a and b are floating point numbers.

<BR></P>

<PRE>fsqrt(<I>number</I>)</PRE>

<P>Returns the floating-point square root for the given number. If the number is negative, 0 is returned.

<BR></P>

<PRE>fsub(<I>a</I>, <I>b</I>)</PRE>

<P>Returns a - b, where a and b are floating point numbers.

<BR></P>

<PRE>get(<I>object</I>, <I>attribute</I>)

get(<I>object</I>/<I>attribute</I>)</PRE>

<P>Returns the specified attribute on the given object.

<BR></P>

<PRE>gt(<I>number1</I>, <I>number2</I>)</PRE>

<P>Returns 1 if number1 is greater than number2, otherwise returns 0.

<BR></P>

<PRE>hasflag(<I>object</I>, <I>flag</I>)</PRE>

<P>Returns 1 if the object has the specified flag, otherwise 0.

<BR></P>

<PRE>host(<I>user</I>)</PRE>

<P>Returns the hostname of user. If the user is not connected, nonexistent, or hidden from you, -1 is returned.

<BR></P>

<PRE>idle(<I>user</I>)</PRE>

<P>Returns the time in seconds that the user has been idle. If the user is not connected, nonexistent, or hidden from you, -1 is returned.

<BR></P>

<PRE>if(<I>test</I>, <I>action</I>)</PRE>

<P>Evaluates the test, and then performs the given action if the test is true; otherwise, it does nothing. The test is false if it evaluates to 0, -1, or to the null string. Otherwise it's true.

<BR></P>

<PRE>ifelse(<I>test</I>, <I>action1</I>, <I>action2</I>)</PRE>

<P>Evaluates the test, and then performs action1 if the test is true and action2 if test is false. The test is false if it evaluates to 0, -1, or to the null string. Otherwise, it's true.

<BR></P>

<PRE>isdigit(<I>argument</I>)</PRE>

<P>Returns 1 if the argument is a digit, 0 if the argument is a letter or a symbol.

<BR></P>

<PRE>land(<I>a</I>, <I>b</I>)</PRE>

<P>Returns the logical AND of a and b.

<BR></P>

<PRE>lattr(<I>object</I>)</PRE>

<P>Returns a list of the attributes on the given objects that have a non-null value.

<BR></P>

<PRE>lattrdef(<I>object</I>)</PRE>

<P>Returns a list of the attributes defined (with @defattr) on the object.

<BR></P>

<PRE>lcon(<I>object</I>)</PRE>

<P>Returns a space-separated list of items from the object.

<BR></P>

<PRE>lexit(<I>object</I>)</PRE>

<P>Returns a space-separated list of exits on the object.

<BR></P>

<PRE>link(<I>object</I>)</PRE>

<P>On an exit, returns the exit's destination; on a player or thing, returns its home;<I> </I>and on a room, returns the room's drop-to room.

<BR></P>

<PRE>linkup(<I>object</I>)</PRE>

<P>Returns a list of DBREFs of objects linked to the given object.

<BR></P>

<PRE>ljust(<I>string</I>, <I>width</I>)</PRE>

<P>Returns the string, left-justified, in a field of the given width.

<BR></P>

<PRE>ln(<I>number</I>)</PRE>

<P>Returns the natural log of the number.

<BR></P>

<PRE>lnot(<I>number</I>)</PRE>

<P>Returns the logical NOT of the number.

<BR></P>

<PRE>lnumber(<I>number</I>)</PRE>

<P>Returns a list of consecutive numbers from 0 to (number-1). The number cannot be larger than 250.

<BR></P>

<PRE>loc(<I>object</I>)</PRE>

<P>Returns the current location (room number) of the object.

<BR></P>

<PRE>log(<I>number</I>)</PRE>

<H3><A ID="I136" NAME="I136">

<FONT SIZE=4>Returns the logarithm base 10 of the number.

<BR></FONT></A></H3>

<PRE>lor(<I>a</I>, <I>b</I>)</PRE>

<P>Returns the logical OR of a and b.

<BR></P>

<PRE>lt(<I>number1</I>, <I>number2</I>)</PRE>

<P>Returns 1 if number1 is less than number2, otherwise returns 0.

<BR></P>

<PRE>lwho()</PRE>

<P>Returns a list of DBREFs of connected users. It costs 50 credits for an object to use this function.

<BR></P>

<PRE>lxor(<I>a</I>,<I> b</I>)</PRE>

<P>Returns the logical XOR of a and b.

<BR></P>

<PRE>match(<I>string1</I>, <I>string2</I>)</PRE>

<P>Returns 1 if string1 matches string2; otherwise returns 0. String2 may contain wild cards.

<BR></P>

<PRE>mid(<I>string</I>, <I>index</I>, <I>numchars</I>)</PRE>

<P>Returns numchars characters from the string, starting at the specified index.

<BR></P>

<PRE>mod(<I>a</I>, <I>b</I>)</PRE>

<P>Returns a mod b (the remainder after integer division).

<BR></P>

<PRE>mul(<I>a</I>, <I>b</I>)</PRE>

<P>Returns a multiplied by b.

<BR></P>

<PRE>name(<I>object</I>)

name(<I>#DBREF</I>)</PRE>

<P>Returns the name of the object. The object itself or a DBREF can be used as the argument.

<BR></P>

<PRE>nearby(<I>object1</I>, <I>object2</I>)</PRE>

<P>Checks to see if object1 and object2 are nearby each other; and returns 1 if they are, 0 if they aren't, and -1 if there is a problem identifying the objects. Two objects are considered nearby if they are in the same room, or if one is inside the other 
one.

<BR></P>

<PRE>next(<I>object</I>)</PRE>

<P>Returns the next thing in a list.

<BR></P>

<PRE>number(<I>object</I>)</PRE>

<P>Returns the DBREF of the object.

<BR></P>

<PRE>objectlist(<I>object</I>)</PRE>

<P>Returns a list of space-separated DBREFs taken from the list of objects beginning with object. For example, here's a way to tell everyone in the room what you're carrying: @foreach objectlist(con(me))=say I've got my %0!.

<BR></P>

<PRE>objectmem(<I>object</I>)</PRE>

<P>Returns number of bytes used by the object in the database.

<BR></P>

<PRE>objectn(<I>object</I>)</PRE>

<P>Returns the correct objective pronoun for the object (him, her, or it). If the object is neither male nor female, the function returns it.

<BR></P>

<PRE>odd(<I>argument</I>)</PRE>

<P>Returns 1 if the argument is an odd number, 0 if even.

<BR></P>

<PRE>onfor(<I>user</I>)</PRE>

<P>Returns the amount of time in seconds that the user has been on-line in the mud. If the user is not connected, nonexistent, or hidden from you, -1 is returned.

<BR></P>

<PRE>owner(<I>object</I>)</PRE>

<P>Returns the DBREF of the object's owner.

<BR></P>

<PRE>parents(<I>object</I>)</PRE>

<P>Returns a space-separated list of the object's parents, in a format suitable for @foreach.

<BR></P>

<PRE>pi()</PRE>

<P>Returns pi.

<BR></P>

<PRE>playmem(<I>player</I>)</PRE>

<P>Returns the total number of bytes used in the database by all objects owned by the player.

<BR></P>

<PRE>plural(<I>number</I>, <I>suffix</I>)</PRE>

<P>Returns the given suffix if the number does not equal 1; otherwise returns a null string.

<BR></P>

<PRE>pos(<I>string1</I>, <I>string2</I>)</PRE>

<P>Returns the position in string2 where string1 first appears.

<BR></P>

<PRE>poss(<I>object</I>)</PRE>

<P>Returns the correct possessive pronoun for the object (his, her, or its). If the object is neither male nor female, the function returns its.

<BR></P>

<PRE>pow(<I>a</I>, <I>b</I>)</PRE>

<P>Returns a to the b'th power, where a and b are floating point numbers.

<BR></P>

<PRE>quota(<I>player</I>)</PRE>

<P>Returns the builder's quota of the player.

<BR></P>

<PRE>quota_left(<I>player</I>)</PRE>

<P>Returns the unused builder's quota of the player.

<BR></P>

<PRE>rand(<I>number</I>)</PRE>

<P>Returns a random number between 0 and (number-1).

<BR></P>

<PRE>remove(<I>string</I>, <I>wordnumber</I>, <I>numwords</I>)</PRE>

<P>Returns the remainder of the string after removing numwords words starting at word number wordnumber. Words are numbered starting at 1.

<BR></P>

<PRE>rest(<I>string</I>)</PRE>

<P>Returns everything but the first word of string.

<BR></P>

<PRE>rjust(<I>string</I>, <I>width</I>)</PRE>

<P>Returns the string, right-justified, in a field of the specified width.

<BR></P>

<PRE>room(<I>object</I>)</PRE>

<P>Checks to see where the object is, and returns the room number. This works no matter how deeply nested the object is within rooms and things.

<BR></P>

<PRE>rtime([<I>seconds</I>])</PRE>

<P>Returns a time readout that can be altered by the specified amount of seconds. You can add the optional argument to xtime() to alter the current rtime. If the seconds argument is omitted, the current time is displayed.

<BR></P>

<PRE>s(<I>string</I>)</PRE>

<P>Performs pronoun substitution on the string.

<BR></P>

<PRE>scomp(<I>string1</I>, <I>string2</I>)</PRE>

<P>Compares the ASCII values of string1 and string2. Returns 0 if string1 = string2, -1 if string1 &lt; string2, and 1 if string1 &gt; string2.

<BR></P>

<PRE>sgn(<I>a</I>)</PRE>

<P>Returns 1 if a &gt; 0, -1 if a &lt; 0, and 0 if a = 0.

<BR></P>

<PRE>simp(<I>floating-point-number</I>)</PRE>

<P>Returns a rounded-off version of a floating-point number.

<BR></P>

<PRE>sin(<I>number</I>)</PRE>

<P>Returns the sine of the given number.

<BR></P>

<PRE>spc(<I>number</I>)</PRE>

<P>Returns a string consisting of the given number of spaces.

<BR></P>

<PRE>strcat(<I>string1</I>, <I>string2</I>)</PRE>

<P>Returns the concatenation of the two strings.

<BR></P>

<PRE>string(<I>character</I>, <I>number</I>)</PRE>

<P>Returns a string made up of the given character, repeated the given number of times.

<BR></P>

<PRE>strlen(string)</PRE>

<P>Returns number of characters in the string.

<BR></P>

<PRE>sqrt(number)</PRE>

<P>Returns square root of the number, rounded down to the nearest integer. If the number is negative, the function returns the square root of the number's absolute value.

<BR></P>

<PRE>sub(<I>a</I>, <I>b</I>)</PRE>

<P>Returns a minus b, where a and b are integers.

<BR></P>

<PRE>subj(<I>object</I>)</PRE>

<P>Returns the correct subject pronoun for the object (he, she, or it). If the object is neither male nor female, this function returns it.

<BR></P>

<PRE>tan(<I>number</I>)</PRE>

<P>Returns the tangent of the given number.

<BR></P>

<PRE>time()</PRE>

<P>Returns the current system time and date in alphanumeric format (although the exact value returned depends on your @tz setting). time() first checks the @tz value on the object calling the function, and if none is present it checks the @tz value of the 
object's owner.

<BR></P>

<PRE>time(<I>tz</I>)</PRE>

<P>Returns the current system time and date, using tz as the timezone value. The tz argument represents a number of hours before or after GMT, and can include an optional :Y or :N suffix to indicate whether or not U.S. style daylight savings time should be 
considered.

<BR></P>

<PRE>truth(<I>a</I>)</PRE>

<P>Returns 0 if a is a null string or 0, otherwise returns 1.

<BR></P>

<PRE>type(<I>object</I>)</PRE>

<P>Returns the object type of the object (room, exit, thing, or player).

<BR></P>

<PRE>v(argument)</PRE>

<P>Returns the value of the variable specified as its argument. Some of the possibilities include:

<BR></P>

<PRE>v(0) ... v(9)</PRE>

<P>Returns the appropriate stack value.

<BR></P>

<PRE>v(va) ... v(vz)</PRE>

<P>Returns the contents of the appropriate object register.

<BR></P>

<PRE>v(#)</PRE>

<P>Returns the DBREF of whoever caused the action.

<BR></P>

<PRE>v(N)</PRE>

<P>Return the object name of whoever caused the action, with its first letter capitalized.

<BR></P>

<PRE>v(n)</PRE>

<P>Returns the object name of whoever caused the action.

<BR></P>

<PRE>v(!)</PRE>

<P>Returns the DBREF of the object calling v().

<BR></P>

<PRE>v(<I>attribute</I>)</PRE>

<P>Returns the value of the appropriate attribute.

<BR></P>

<PRE>wcount(<I>string</I>)</PRE>

<P>Returns the number of words in the given string.

<BR></P>

<PRE>wmatch(<I>string</I>, <I>argument</I>)</PRE>

<P>Locates the position of the given argument in the string, where the given string is a series of words and/or numbers, separated by spaces. Returns 0 if the argument is not in the string. Not case-sensitive.

<BR></P>

<H4><A ID="I137" NAME="I137">

<FONT SIZE=3><B>Lock Reference</B>

<BR></FONT></A></H4>

<P>Locks are used to make the successful use of objects possible or impossible, depending upon various things (for example, who's doing the attempting, what they're carrying, what room the attempt is occurring in, and so forth). There are many types of 
locks, including regular locks (@lock), enter-locks (@elock), leave-locks (@llock), and use-locks (@ulock). You can apply the full variety of <I>lock options</I> to any one these lock types.

<BR></P>

<P>Lock options are applied by the use of punctuation in lock command statements. The following examples refer to the @lock, but the same options can be applied to all types of locks.

<BR></P>

<P>Any lock may be combined with any other in a Boolean expression, by using &amp; (and), | (or), and ! (not) symbols. You can also use parentheses () to group objects into logical elements. The lock in question will be &quot;satisfied&quot; if the Boolean 
expression evaluates to true.

<BR></P>

<H4><A ID="I138" NAME="I138">

<FONT SIZE=3><B>Locks</B>

<BR></FONT></A></H4>

<PRE>@lock <I>thing</I>=<I>object</I></PRE>

<P>Ordinary Lock. Checks against the player or object that tries to pick up the locked object (or walk through the locked exit), but also checks against all objects carried by the enactor.

<BR></P>

<PRE>@lock <I>thing</I>=+<I>object</I>

&quot;Carry Lock.&quot;</PRE>

<P>Checks only against objects carried by the enactor, not against the enactor itself.

<BR></P>

<PRE>@lock <I>thing</I>=@<I>object</I>

&quot;Indirect Locks.&quot;</PRE>

<P>Checks exactly as specified by the other object's lock.

<BR></P>

<PRE>@lock <I>thing</I>==<I>object</I>

&quot;Is Lock.&quot;</PRE>

<P>Checks against the enactor only, not against objects the enactor carries.

<BR></P>

<PRE>@lock <I>thing</I>=@(<I>object</I>=<I>attribute</I>:<I>value</I>)

&quot;Object Attribute Lock.&quot;</PRE>

<P>Checks the value of an attribute on another object (rather than on the enactor).

<BR></P>

<PRE>@lock <I>thing</I>=*<I>player</I>

&quot;Player Lock.&quot;</PRE>

<P>Locks object for a specific player.

<BR></P>

<PRE>@<I>attribute</I> <I>object</I>=$<I>pattern</I>:/<I>lock</I>/<I>actions</I>

&quot;Register Lock.&quot;</PRE>

<P>Locks a specific $ or ! event. Different from an @ulock, which locks all $ and ! events on the object.

<BR></P>

<H4><A ID="I139" NAME="I139">

<FONT SIZE=3><B>Object Design Worksheet</B>

<BR></FONT></A></H4>

<P>The following worksheet might come in handy for your complex objects.

<BR></P>

<PRE>OBJECT NAME: ____________________________________  OBJECT NUMBER: ____

OBJECT TYPE: ___________________  OBJECT'S OWNER: ____________________

LINKED TO: _____________________  LOCKED TO: ___________  COST: ______

REGISTER                   CONTENTS/NOTES                      OPTIONS

======== ===================================================== =======

DESC     _____________________________________________________ _______

ODESC    _____________________________________________________ _______

ADESC    _____________________________________________________ _______

IDESC    _____________________________________________________ _______

SUCC     _____________________________________________________ _______

OSUCC    _____________________________________________________ _______

ASUCC    _____________________________________________________ _______

FAIL     _____________________________________________________ _______

OFAIL    _____________________________________________________ _______

AFAIL    _____________________________________________________ _______

DROP     _____________________________________________________ _______

ADROP    _____________________________________________________ _______

ODROP    _____________________________________________________ _______

ENTER    _____________________________________________________ _______

AENTER   _____________________________________________________ _______

OENTER   _____________________________________________________ _______

LEAVE    _____________________________________________________ _______

OLEAVE   _____________________________________________________ _______

ALEAVE   _____________________________________________________ _______

VA       _____________________________________________________ _______

VB       _____________________________________________________ _______

VC       _____________________________________________________ _______

VD       _____________________________________________________ _______

VE       _____________________________________________________ _______

VF       _____________________________________________________ _______

VG       _____________________________________________________ _______

VH       _____________________________________________________ _______

VI       _____________________________________________________ _______

VJ       _____________________________________________________ _______

VK       _____________________________________________________ _______

VL       _____________________________________________________ _______

VM       _____________________________________________________ _______

VN       _____________________________________________________ _______

VO       _____________________________________________________ _______

VP       _____________________________________________________ _______

VQ       _____________________________________________________ _______

VR       _____________________________________________________ _______

VS       _____________________________________________________ _______

VT       _____________________________________________________ _______

VU       _____________________________________________________ _______

VV       _____________________________________________________ _______

VW       _____________________________________________________ _______

VX       _____________________________________________________ _______

VY       _____________________________________________________ _______

VZ       _____________________________________________________ _______

FLAGS (circle):

Chown_ok  Dark  destroy_ok  enter_ok  Haven  Inherit  Jump_ok  Link_ok No_walls  opaque  puppet(of:___________)  visible

ATTRIBUTE OPTIONS (circle):

dark  date  function(__________________)  inherit  lock  osee  unsaved  wizard

MISCELLANEOUS: _______________________________________________________</PRE>

<H3><A ID="I140" NAME="I140">

<FONT SIZE=4><B>How To Program a MOO</B>

<BR></FONT></A></H3>

<P><I>MOO</I> stands for <I>MUD Object-Oriented</I>. The original MOO was <I>TinyMOO</I>, developed by Steven White. TinyMOO was then expanded and developed further by Pavel Curtis, who called his version <I>LambdaMOO</I>. Almost all of the MOOs running 
today are LambdaMOOs.

<BR></P>

<P>MOOs are similar to TinyMUD-based muds, such as MUCK, MUSH, and MUSE, but they have enough differences to warrant their own section. Some of the differences are fairly cosmetic, such as certain commands having slightly different names and syntax More 
importantly, though, MOOs differ from other TinyMUD-based muds in the underlying paradigm: MOOs are object-oriented.

<BR></P>

<P>In procedural environments, the data and the functions that operate on that data are separate. In object-oriented environments, objects contain both the data and the functions that operate on the data. This allows functionality to be grouped into more 
cohesive units. It also allows objects to be aware of &quot;themselves.&quot; In MOO, an object contains attributes that store the data and verbs that define functions that operate on the data.

<BR></P>

<P>Objects can also inherit functionality from other objects in MOO. You can create generic objects that behave in a certain manner, and then create specific sub-types of these generic objects. You can then write functions on the specific objects, and 
perhaps override functions defined on the generic objects.

<BR></P>

<H4><A ID="I141" NAME="I141">

<FONT SIZE=3><B>Popular MOOs</B>

<BR></FONT></A></H4>

<P>Here are some popular MOOs.

<BR></P>

<TABLE BORDER>

<TR>

<TD>

<PRE><B><I>Name</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Machine Name</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Internet Address</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Port</I></B>

<BR></PRE>

<TR>

<TD>

<P>Diversity University</P>

<TD>

<P>erau.db.erau.edu</P>

<TD>

<P>155.31.1.1</P>

<TD>

<P>8888</P>

<TR>

<TD>

<P>Jay's House MOO</P>

<TD>

<P>jhm.ccs.neu.edu</P>

<TD>

<P>129.10.111.77</P>

<TD>

<P>1709</P>

<TR>

<TD>

<P>LambdaMOO</P>

<TD>

<P>lambda.parc.xerox.com</P>

<TD>

<P>192.216.54.2</P>

<TD>

<P>8888</P>

<TR>

<TD>

<P>MediaMOO</P>

<TD>

<P>purple-crayon.media.mit.edu</P>

<TD>

<P>18.85.0.48</P>

<TD>

<P>8888</P>

<TR>

<TD>

<P>ZenMOO</P>

<TD>

<P>cheshire.oxy.edu</P>

<TD>

<P>134.69.1.253</P>

<TD>

<P>7777</P></TABLE>

<P>LambdaMOO is the flagship MOO. It resides at Xerox PARC. Its chief maintainer, Pavel Curtis, maintains the MOO server code.

<BR></P>

<P>MediaMOO is a MOO devoted to media research. If you work in the media field&#151;perhaps as an English professor, a journalist, or someone researching virtual reality&#151;you may want to sign up on this MOO.

<BR></P>

<P>These addresses are current as of August, 1994. Keep in mind that they may change.

<BR></P>

<H4><A ID="I142" NAME="I142">

<FONT SIZE=3><B>Basic Concepts</B>

<BR></FONT></A></H4>

<P>This section on MOOs assumes that you have read the previous sections on MUCKs, MUSHes, and MUSEs, since many of the concepts in MUCKs, MUSHes, and MUSEs can also be found in MOOs. Most of the commands available in TinyMUD-based muds have corresponding 
analogues in MOOs.

<BR></P>

<H5><A ID="I143" NAME="I143">

<FONT SIZE=3><B>Basic Values</B>

<BR></FONT></A></H5>

<P>MOOs, like other types of muds, have the basic values of numbers and strings. Numbers are always integers, and strings are enclosed in double-quotes. MOOs also have <I>lists</I>, which can be a list of any type of value. MOOs also have special values 
called <I>errors</I>. These errors are simply codes that can be used to check to see if some action is performed successfully. In the event of an error, the error code can be used in some manner. Lastly, MOOs have <I>objects</I>. Objects are a combination 
of functionality (verbs) and data (properties).

<BR></P>

<H5><A ID="I144" NAME="I144">

<FONT SIZE=3><B>Object Numbers</B>

<BR></FONT></A></H5>

<P>Each object in a MOO has a database reference number, just like each object in a TinyMUD-based mud, except that instead of it being called a DBREF, it is called an <I>object number</I>. Object numbers are completely synonymous with object names; in 
fact, you can use object numbers instead of object names. For instance, if a potted plant was object number 735 and a table was object number 675, you could type put #735 on #675 instead of put potted plant on table.

<BR></P>

<H5><A ID="I145" NAME="I145">

<FONT SIZE=3><B>Inheritance</B>

<BR></FONT></A></H5>

<P>Objects can <I>inherit</I> values from other objects. For instance, you can create a car, and define various actions on it, such as drive. Then you can create a sports car that derives from the generic car, and performs special actions, such as revving 
the engine. It can also override the functionality of the object it is derived from, such as overriding the drive function to do something special that pertains to sports cars.

<BR></P>

<P>In this example, the generic car is called the <I>parent</I> object, and the specialized object that derives from it, the sports car, is called a <I>child</I> object. Child objects can override the functionality of their parent objects. If they don't, 
the default parent object's functionality is used. Objects can have children, and those children can have other children objects, and so forth.

<BR></P>

<H5><A ID="I146" NAME="I146">

<FONT SIZE=3><B>Verbs</B>

<BR></FONT></A></H5>

<P><I>Verbs</I> are the functions that objects can have that enable them to perform operations on their attributes, calculate things, and respond to actions and events. They are similar to attributes that define action lists, but they are more powerful 
because you can inherit from them.

<BR></P>

<P>Verbs are actually little programs that are defined on an object. The generic thing object has several predefined verbs already written on it, and you can add to these predefined functions, or override them to perform specialized tasks. Verbs defined on 
a parent object are also defined on their children, unless they are overridden.

<BR></P>

<P>Verbs are denoted using a colon with their object:

<BR></P>

<PRE><I>object-name</I>:<I>verb-name</I>

<I>object-number</I>:<I>verb-name</I></PRE>

<P>So, if you have a chair that has a sit verb defined on it, you can refer to that verb as:

<BR></P>

<PRE>chair:sit</PRE>

<P>If the chair is object #788, you can also use:

<BR></P>

<PRE>#788:sit</PRE>

<H5><A ID="I147" NAME="I147">

<FONT SIZE=3><B>Properties</B>

<BR></FONT></A></H5>

<P>A <I>property</I> is a value that is stored on an object. It is similar to an attribute in TinyMUD, except that TinyMUD attributes can contain actions, whereas MOO properties are simply slots to store information about the object. Properties are 
typeless; that is, they can store any type of data field: numbers, strings, lists, and even other objects.

<BR></P>

<P>You refer to properties by using a period with their object:

<BR></P>

<PRE><I>object-name</I>.<I>property</I>

<I>object-number</I>.<I>property</I></PRE>

<P>You set these properties with the @property command:

<BR></P>

<PRE>@property <I>property-name value</I></PRE>

<P>For example:

<BR></P>

<PRE>@property deck.numcards 52</PRE>

<H5><A ID="I148" NAME="I148">

<FONT SIZE=3><B>Messages</B>

<BR></FONT></A></H5>

<P><I>Messages</I> are properties that end with the suffix _msg. These messages are special kinds of properties. These messages correspond to certain kinds of verbs. For instance, a message corresponding to a fly verb might be called a fly_msg. Most of the 
string attributes, such as an object's description, are actually messages that have been defined on those objects.

<BR></P>

<H5><A ID="I149" NAME="I149">

<FONT SIZE=3><B>Inspecting Objects</B>

<BR></FONT></A></H5>

<P>You can see an object's description in MOO in the same manner as in TinyMUD, by using the look command:

<BR></P>

<PRE>look <I>object</I></PRE>

<P>If you examine the object, you can obtain the description, verbs, and properties on the object:

<BR></P>

<PRE>@examine <I>object</I></PRE>

<P>Further information can be obtained using the show command. This command displays the object's name and number, its parent object's name and number, its owner's name and number, and a list of verbs and properties defined on the object:

<BR></P>

<PRE>@show <I>object</I></PRE>

<P>The messages on an object can be viewed using:

<BR></P>

<PRE>@messages <I>object</I></PRE>

<P>The dump command lists the programs associated with each verb defined on an object. It does not check for inherited verbs.

<BR></P>

<PRE>@dump <I>object</I></PRE>

<P>To get the program listing for a specific verb, use:

<BR></P>

<PRE>@dump <I>object</I>:<I>verb-name</I></PRE>

<P>You can also use:

<BR></P>

<PRE>@list <I>object</I>:<I>verb-name</I></PRE>

<H4><A ID="I150" NAME="I150">

<FONT SIZE=3><B>Basic Commands</B>

<BR></FONT></A></H4>

<P>Let's digress for a moment and present commands in MOO that have equivalent commands in TinyMUD-based muds.

<BR></P>

<P>Many MOO commands are similar to TinyMUD-type commands. Here is a list of basic TinyMUD commands and their MOO equivalents. If you haven't read the &quot;Overview of Common Commands&quot; section in this chapter, and the sections on MUCKs, MUSHes, and 
MUSEs, you may want to go back and read those sections first.

<BR></P>

<TABLE BORDER>

<TR>

<TD>

<PRE><B><I>Command</I></B>

<BR></PRE>

<TD>

<PRE><B><I>TinyMUD command</I></B>

<BR></PRE>

<TD>

<PRE><B><I>MOO Equivalent</I></B>

<BR></PRE>

<TR>

<TD>

<P>acting</P>

<TD>

<P>: (colon)</P>

<TD>

<P>same</P>

<TR>

<TD>

<P>dropping</P>

<TD>

<P>drop <I>object</I></P>

<TD>

<P>same</P>

<TR>

<TD>

<P>examining</P>

<TD>

<P>examine <I>object</I></P>

<TD>

<P>@examine <I>object</I></P>

<TR>

<TD>

<P>getting</P>

<TD>

<P>get <I>object</I></P>

<TD>

<P>same</P>

<TR>

<TD>

<P>going home</P>

<TD>

<P>home</P>

<TD>

<P>same</P>

<TR>

<TD>

<P>inventory</P>

<TD>

<P>inventory</P>

<TD>

<P>same</P>

<TR>

<TD>

<P>killing</P>

<TD>

<P>kill <I>object</I></P>

<TD>

<P>not present</P>

<TR>

<TD>

<P>listing players</P>

<TD>

<P>WHO</P>

<TD>

<P>@who</P>

<TR>

<TD>

<P>looking</P>

<TD>

<P>look <I>object</I></P>

<TD>

<P>same</P>

<TR>

<TD>

<P>moving</P>

<TD>

<P>go <I>place</I></P>

<TD>

<P>same</P>

<TR>

<TD>

<P>paging</P>

<TD>

<P>page <I>player</I> = <I>message</I></P>

<TD>

<P>page <I>player</I> &quot;<I>message</I>&quot;</P>

<TR>

<TD>

<P>quitting</P>

<TD>

<P>QUIT</P>

<TD>

<P>@quit</P>

<TR>

<TD>

<P>talking</P>

<TD>

<P>&quot; (double-quote)</P>

<TD>

<P>same</P>

<TR>

<TD>

<P>whispering</P>

<TD>

<P>whisper <I>player</I> = <I>message</I></P>

<TD>

<P>whisper &quot;<I>message</I>&quot; to <I>player</I></P></TABLE>

<H4><A ID="I151" NAME="I151">

<FONT SIZE=3><B><I>At-</I></B><B>Command Equivalencies</B>

<BR></FONT></A></H4>

<P>For a quick introduction, here is a list of TinyMUD at-commands and their MOO equivalents. For more detail, consult the &quot;MOO Reference Manual&quot; sections on &quot;At-Commands&quot; and &quot;Messages,&quot; given later in this chapter.

<BR></P>

<TABLE BORDER>

<TR>

<TD>

<P>TinyMUD At-Command</P>

<TD>

<P>MOO Equivalent</P>

<TR>

<TD>

<P>@create object = cost</P>

<TD>

<P>@create object named &quot;name&quot;</P>

<TR>

<TD>

<P>@desc object = description</P>

<TD>

<P>@describe object as &quot;description&quot;</P>

<TR>

<TD>

<P>@dig room-name</P>

<TD>

<P>@dig room-name</P>

<TR>

<TD>

<TD>

<P>@dig exit-name to place</P>

<TR>

<TD>

<P>@drop object = message</P>

<TD>

<P>@arrive exit is &quot;message&quot;</P>

<TR>

<TD>

<P>@fail object = message</P>

<TD>

<P>@take_failed object is &quot;message&quot;</P>

<TR>

<TD>

<TD>

<P>@nogo exit is &quot;message&quot;</P>

<TR>

<TD>

<P>@find</P>

<TD>

<P>@audit</P>

<TR>

<TD>

<P>@link</P>

<TD>

<P>None. Use @dig.</P>

<TR>

<TD>

<P>@name</P>

<TD>

<P>@rename</P>

<TR>

<TD>

<P>@ofail object = message</P>

<TD>

<P>@otake_failed object is &quot;message&quot;</P>

<TR>

<TD>

<TD>

<P>@onogo exit is &quot;message&quot;</P>

<TR>

<TD>

<P>@open</P>

<TD>

<P>None. Use @dig.</P>

<TR>

<TD>

<P>@osucc object = message</P>

<TD>

<P>@otake_succeeded object is</P>

<TR>

<TD>

<TD>

<P>&quot;message&quot;</P>

<TR>

<TD>

<TD>

<P>@oleave exit is &quot;message&quot;</P>

<TR>

<TD>

<TD>

<P>@oarrive exit is &quot;message&quot;</P>

<TR>

<TD>

<P>@succ <I>object</I> = <I>message</I></P>

<TD>

<P>@take_succeeded <I>object</I> is &quot;<I>message</I>&quot;</P>

<TR>

<TD>

<TD>

<P>@leave <I>exit</I> is &quot;<I>message</I>&quot;</P>

<TR>

<TD>

<TD>

<P>@arrive <I>exit</I> is &quot;<I>message</I>&quot;</P></TABLE>

<H4><A ID="I152" NAME="I152">

<FONT SIZE=3><B>MOO Programming</B>

<BR></FONT></A></H4>

<P>Now that you have had an introduction to basic MOO concepts, and you have seen which other TinyMUD-based commands have equivalencies in MOOs, you can delve into MOO programming.

<BR></P>

<P>If you have programmed in the C programming language, you will find yourself quite familiar with the programming constructs in MOOs, because they are almost exactly the same.

<BR></P>

<P>This section assumes you have had some prior experience using the C programming language. As such, it presents the programming concepts in a quick overview fashion, rather than an extensive tutorial on computer programming.

<BR></P>

<H5><A ID="I153" NAME="I153">

<FONT SIZE=3><B>Expressions</B>

<BR></FONT></A></H5>

<P>Expressions evaluate to either true (non-zero) or false (zero). They are used for comparisons, conditional statements, and so forth.

<BR></P>

<P>The simplest expressions are literal values:

<BR></P>

<PRE><I>number</I>

# <I>object-number</I>

&quot;<I>string</I>&quot;

<I>error-code</I>

<I>variable</I></PRE>

<P>Next, you can create lists of expressions using:

<BR></P>

<PRE>{ <I>expr</I>, <I>expr</I>, ... <I>expr</I> }</PRE>

<P>These values can then be put together in more complex expressions:

<BR></P>

<TABLE BORDER>

<TR>

<TD>

<PRE><B><I>Expression</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Meaning</I></B>

<BR></PRE>

<TR>

<TD>

<P><I>expr</I>.<I>name</I></P>

<TD>

<P>Property access.</P>

<TR>

<TD>

<P><I>expr</I>.(<I>name</I>)</P>

<TD>

<P>Property access, where <I>name</I> is a string denoting the property.</P>

<TR>

<TD>

<P><I>expr</I>:<I>name</I>(<I>arguments</I>)</P>

<TD>

<P>Call a verb.</P>

<TR>

<TD>

<P><I>expr</I>:(<I>name</I>)(<I>arguments</I>)</P>

<TD>

<P>Call a verb, where <I>name</I> is a string denoting the verb.</P>

<TR>

<TD>

<P><I>function</I>(<I>arguments</I>)</P>

<TD>

<P>Call one of the built-in MOO functions.</P>

<TR>

<TD>

<P><I>expr</I>[<I>expr</I>]</P>

<TD>

<P>Index into a string or list.</P>

<TR>

<TD>

<P><I>expr</I>[<I>expr</I> .. <I>expr</I>]</P>

<TD>

<P>Get a slice of a string or list.</P>

<TR>

<TD>

<P><I>name</I> = <I>expr</I></P>

<TD>

<P>Set a variable.</P>

<TR>

<TD>

<P><I>expr</I>.<I>name</I> = <I>expr</I></P>

<TD>

<P>Set a property.</P>

<TR>

<TD>

<P><I>expr</I> + <I>expr</I></P>

<TD>

<P>Add two expressions.</P>

<TR>

<TD>

<P><I>expr</I> - <I>expr</I></P>

<TD>

<P>Subtract expressions from another.</P>

<TR>

<TD>

<P><I>expr</I> * <I>expr</I></P>

<TD>

<P>Multiply two expressions.</P>

<TR>

<TD>

<P><I>expr</I> / <I>expr</I></P>

<TD>

<P>Divide one expression by another.</P>

<TR>

<TD>

<P><I>expr</I> % <I>expr</I></P>

<TD>

<P>Return the remainder of one expression divided by another.</P>

<TR>

<TD>

<P>- <I>expr</I></P>

<TD>

<P>Add two expressions.</P>

<TR>

<TD>

<P><I>expr</I> == <I>expr</I></P>

<TD>

<P>Compare two expressions for equality.</P>

<TR>

<TD>

<P><I>expr</I> != <I>expr</I></P>

<TD>

<P>Compare two expressions for inequality.</P>

<TR>

<TD>

<P><I>expr</I> &lt; <I>expr</I></P>

<TD>

<P>See if one expression is less than another.</P>

<TR>

<TD>

<P><I>expr</I> &lt;= <I>expr</I></P>

<TD>

<P>See if one expression is less than or equal to another.</P>

<TR>

<TD>

<P><I>expr</I> &gt; <I>expr</I></P>

<TD>

<P>See if one expression is greater than another.</P>

<TR>

<TD>

<P><I>expr</I> &gt;= <I>expr</I></P>

<TD>

<P>See if one expression is greater than or equal to another.</P>

<TR>

<TD>

<P><I>expr</I> &amp;&amp; <I>expr</I></P>

<TD>

<P>Determine the logical AND of two expressions.</P>

<TR>

<TD>

<P><I>expr</I> || <I>expr</I></P>

<TD>

<P>Determine the logical OR of two expressions.</P>

<TR>

<TD>

<P>! <I>expr</I></P>

<TD>

<P>Determine the logical NOT of an expression.</P>

<TR>

<TD>

<P><I>expr</I> IN <I>expr</I></P>

<TD>

<P>Test for set inclusion.</P>

<TR>

<TD>

<P><I>b-expr</I> ? <I>t-expr</I> | <I>f-expr</I></P>

<TD>

<P>Test b-expr. If true, return t-expr. If false, return f-expr.</P></TABLE>

<P>Most of these are the same as in the C programming language. Note that the tertiary expression (given last) contains a vertical line (|) in MOO, as opposed to a colon (:) in C.

<BR></P>

<H5><A ID="I154" NAME="I154">

<FONT SIZE=3><B>Statements</B>

<BR></FONT></A></H5>

<P>You can use the expressions to create statements.

<BR></P>

<P>The simplest statement is the null statement, a semi-colon (;), which does nothing.

<BR></P>

<P>The conditional statement has the following syntax:

<BR></P>

<PRE>if (<I>expr</I>)

   <I>statements</I>

elseif (<I>expr</I>)

   <I>statements</I>

else

   <I>statements</I>

endif</PRE>

<P>The else-if and else clauses are optional. You need to use them only when you want to test further conditions or perform an action if the expression is false, respectively.

<BR></P>

<P>The list iteration statement has the following syntax:

<BR></P>

<PRE>for <I>name</I> in (<I>expr</I>)

   <I>statements</I>

endfor</PRE>

<P>and the numeric iteration statement is:

<BR></P>

<PRE>for <I>name</I> in [<I>expr</I> .. <I>expr</I>]

   <I>statements</I>

endfor</PRE>

<P>In this regard, the iteration statements are closer to the Pascal programming language than to the C programming language.

<BR></P>

<P>The indefinite iteration statement is:

<BR></P>

<PRE>while (<I>expr</I>)

   <I>statements</I>

endwhile</PRE>

<P>To return a value from a verb, use:

<BR></P>

<PRE>return <I>expr</I>;</PRE>

<P>or

<BR></P>

<PRE>return ;</PRE>

<P>Finally, to fork a task:

<BR></P>

<PRE>fork <I>name</I> (<I>seconds-expr</I>)

   <I>statements</I>

endfork</PRE>

<P>This last statement evaluates the expression to a number of seconds. After waiting that many seconds, a separate task will execute the given statements. Execution simultaneously continues with the statements, if any, after the endfork.

<BR></P>

<H5><A ID="I155" NAME="I155">

<FONT SIZE=3><B>Entering Verbs</B>

<BR></FONT></A></H5>

<P>To program a verb on an object, use the @program command:

<BR></P>

<PRE>@program <I>object</I>:<I>verb</I></PRE>

<P>This puts you into the MOO editor. You can type in your verb program, one statement per line. The program is interpreted as a list of strings. At the end, you type a period on a line by itself

<BR></P>

<PRE>.</PRE>

<P>to tell the MOO that your verb program is complete. The MOO then error-checks it. If it is correct, the program becomes the new program for that verb on that object.

<BR></P>

<P>If you are entering a verb program and you want to abort the editing, type

<BR></P>

<PRE>@abort</PRE>

<P>on a line by itself. The editor will terminate, and the verb will remain unchanged.

<BR></P>

<H3><A ID="I156" NAME="I156">

<FONT SIZE=4><B>MOO Reference Manual</B>

<BR></FONT></A></H3>

<P>This section is a reference to MOOs. It lists at-commands, common functions, messages, and other information pertaining to MOOs.

<BR></P>

<H4><A ID="I157" NAME="I157">

<FONT SIZE=3><B><I>At</I></B><B>-Command Reference</B>

<BR></FONT></A></H4>

<PRE>@addalias <I>alias</I> to <I>object</I>

@addalias <I>alias</I> to <I>object</I>:<I>verb</I></PRE>

<P>Adds an alias to the name of the object or the verb on an object, respectively. For example, if you want a Corvette that you create to also be known as a car, you can use this command to add the alias &quot;car&quot; to the Corvette.

<BR></P>

<PRE>@add-entrance <I>exit-obj-number</I></PRE>

<P>Links the given exit object to the current room as an entrance.

<BR></P>

<PRE>@add-exit<I> exit-obj-number</I></PRE>

<P>Links the given exit object to the current room as an exit.

<BR></P>

<PRE>@add-feature <I>feature-object</I></PRE>

<P>Adds the specified feature object to you. Features are objects that provide additional functionality to you. For example, one common feature is one where you can begin a line with a minus symbol (-), followed by a name and some text, and it will perform 
a directed say command at that person:

<BR></P>

<PRE>&gt; -George Hey there!

You say [to George] &quot;Hey there!&quot;</PRE>

<P>You can find out the object number of this feature on your MOO by using the @features command, and thus add it to your feature list.

<BR></P>

<PRE>@args <I>object</I>:<I>verb</I> <I>direct-obj</I>

@args <I>object</I>:<I>verb</I> <I>direct-obj preposition</I>

@args <I>object</I>:<I>verb direct-obj preposition indirect-obj</I></PRE>

<P>These three commands set the direct object, preposition, and indirect object specifiers on the given object's verb.

<BR></P>

<PRE>@audit</PRE>

<P>Prints out a list of everything that you own.

<BR></P>

<PRE>@check-chparent <I>object</I> to <I>new-parent-obj</I></PRE>

<P>Sees if the specified parent object is already the parent of the given object.

<BR></P>

<PRE>@check-property <I>object.property</I></PRE>

<P>Sees if the specified property already exists on the given object.

<BR></P>

<PRE>@chmod <I>object permissions</I>

@chmod <I>object</I>:<I>verb permissions</I>

@chmod <I>object</I>.<I>property permissions</I></PRE>

<P>Changes the permissions on the object, verb, or property, respectively. The permissions are given by a string. The valid object permissions are r, w, and f. The valid verb permissions are r, w, x, and d. The valid property permissions are r, w, and c.

<BR></P>

<PRE>@chparent <I>object</I> to <I>new-parent</I></PRE>

<P>Changes the parent of the specified object to the new parent object. The object will inherit all the verb and property definitions of the parent object.

<BR></P>

<PRE>@classes</PRE>

<P>Lists the classes available for you to use. You might want to check this out when you are first starting.

<BR></P>

<PRE>@clear-property <I>object</I>.<I>property</I></PRE>

<P>Changes the property to use value of the parent object's property instead of itself.

<BR></P>

<PRE>@contents <I>object</I></PRE>

<P>Lists the contents of the given object.

<BR></P>

<PRE>@copy <I>object</I>:<I>verb</I> to <I>new-object</I>:<I>new-verb</I></PRE>

<P>Copies the arguments, code, and other associated information of the specified object's verb to the new object's verb.

<BR></P>

<PRE>@count</PRE>

<P>Displays the number of objects that you own. Remember that your character itself is an object that you own.

<BR></P>

<PRE>@create <I>class-name</I> named &quot;<I>object-names</I>&quot;

@create <I>parent-obj</I> named &quot;<I>object-names</I>&quot;</PRE>

<P>Creates a new object. The first form specifies one of the generic classes to use as the new object's parent. The second form uses the given parent object as the new object's parent. The object names string is a list of comma-separated aliases for the 
name of the object. The first item in the string will be used as the name of the new object, and the rest of the items in the string are aliases for that object.

<BR></P>

<PRE>&gt; @create $thing named &quot;Vehicle&quot;

&gt; @create Vehicle named &quot;Dodge Viper,viper,car&quot;

@describe <I>object</I> as <I>description</I></PRE>

<P>Sets the description on the object.

<BR></P>

<PRE>@dig &quot;<I>place</I>&quot;

@dig <I>exits-to</I>|<I>exits-from</I> to &quot;<I>place</I>&quot;

@dig <I>exits-to</I>|<I>exits-from</I> to <I>room-obj-number</I></PRE>

<P>Creates a room. The first form simply creates a room with that name, and tells you the object number of the newly created room. The second form also creates exits to and from the newly created room. The exits-to links the current room to the new room, 
and the exits-from links the new room back to the current room. You must own the current room in order to link to it. If you do not own the current room, you should take note of the exit object numbers and get the owner of the current room to @add-exit and 
@add-entrance the exit objects to their room.

<BR></P>

<PRE>@disinherit <I>child-object</I> [ from <I>parent-object</I> ]</PRE>

<P>Removes a child object from the parent object. You must own the parent, but you do not have to own the child object.

<BR></P>

<PRE>@display <I>object</I></PRE>

<P>Displays information about the object in a formatted manner. See the MOO help on your system for a detailed description of the options available.

<BR></P>

<PRE>@display-option</PRE>

<P>Allows you to customize the formatting of the @display command. See the MOO help on your system for a detailed description of the options available.

<BR></P>

<PRE>@dump <I>object</I></PRE>

<P>This command displays the verbs and properties that have been defined on the given object.

<BR></P>

<PRE>@edit <I>object</I>:<I>verb</I></PRE>

<P>Enables you to edit the verb on the given object. This command puts you into the MOO editor.

<BR></P>

<PRE>@edit-option</PRE>

<P>Enables you to customize the editor that is invoked when you enter a verb program using @program, or compose a mail message, and so forth. See the MOO help on your system for a detailed description of the options available.

<BR></P>

<PRE>@eject <I>object</I> [ from <I>room</I> ]</PRE>

<P>Removes the object from the current room, or the specified room if that is given. Objects thus removed are sent home.

<BR></P>

<PRE>@entrances</PRE>

<P>Lists the entrances into the current room. You must own the current room in order to see this.

<BR></P>

<PRE>@examine <I>object</I></PRE>

<P>Displays a more detailed description of the given object. The description contains the object's full name, object number, aliases, owner's name, and object number, its description, its contents, and readable verbs defined on the object.

<BR></P>

<PRE>@exits</PRE>

<P>Lists the exits from the current room. You must own the current room in order to see this.

<BR></P>

<PRE>@features</PRE>

<P>Lists the features on your system that you can use. You can add these features to your player object by using the @add feature, and you can remove features from your player object by using the @remove feature.

<BR></P>

<PRE>@forked</PRE>

<P>Lists the forked tasks that you own.

<BR></P>

<PRE>@gag <I>object</I></PRE>

<P>Prevents you from seeing messages or text from the specified object, which is usually a player. This is useful when you want to ignore someone who is being annoying or generating a lot of output.

<BR></P>

<PRE>@gaglist</PRE>

<P>Lists the objects you currently have gagged.

<BR></P>

<PRE>@gender <I>object</I></PRE>

<P>Sets the gender of the specified object.

<BR></P>

<PRE>@go <I>place</I>

@go <I>room-obj-number</I></PRE>

<P>Teleports you to the specified place or room number. On some MOOs, a route is computed and you walk room by room to the destination rather than being magically teleported there.

<BR></P>

<PRE>@hide</PRE>

<P>Removes your character from appearing in the WHO list. However, you will still show up if someone specifically uses your name in a command such as @whois.

<BR></P>

<PRE>@kids <I>object</I></PRE>

<P>Lists the children of the specified object.

<BR></P>

<PRE>@kill <I>task</I></PRE>

<P>Enables you to kill off a task. See the MOO help on your system for a more detailed description of this command.

<BR></P>

<PRE>@lastlog [ <I>player</I> ]</PRE>

<P>Displays the last login times of the players in the database. If you specify a player name, it displays the last time that player was connected to the MOO.

<BR></P>

<PRE>@linelength <I>number</I></PRE>

<P>Sets the length of a line on your screen. The MOO will use this length to break up text that is displayed to you. However, it is better to use a client program that provides this functionality than for you to have the MOO do it for you, since the MOO 
does it slower.

<BR></P>

<PRE>@list <I>object</I>:<I>verb</I></PRE>

<P>Displays the code for the given object's verb.

<BR></P>

<PRE>@more</PRE>

<P>Sets your display to print out long messages in a page-by-page fashion. This command uses the @pagelength value to determine how long your screen is. If a displayed message is longer than your page length, the display is halted and you will see an 
indicator that there is more to follow.

<BR></P>

<PRE>@opacity <I>object</I> is <I>number</I></PRE>

<P>Sets the opacity for the given object, usually a container. The opacity number is one of three values. If the number is 0, the container is transparent, and you can see into it. If the number is 1, the container is opaque, and you cannot see into it 
when the container is closed. If the number is 2, you cannot see into it even if it is open.

<BR></P>

<PRE>@pagelength</PRE>

<P>Sets the number of lines you want to have displayed to you at one time when long messages are sent to you. Also see @more.

<BR></P>

<PRE>@parents <I>object</I></PRE>

<P>Displays the name and object number of all of the given object's ancestors.

<BR></P>

<PRE>@password <I>old-password new-password</I></PRE>

<P>Changes your password from the old value to the new value.

<BR></P>

<PRE>@program <I>object</I>:<I>verb</I></PRE>

<P>Allows you to enter code for the given object verb. This command puts you into the MOO editor. For details on the commands available for use in the MOO editor, consult the editor help on your MOO system.

<BR></P>

<PRE>@property <I>object</I>.<I>property</I> [ <I>initial-value</I> ]</PRE>

<P>Sets the given object's property to the specified initial value. If the initial value is omitted, the property is initially set to 0.

<BR></P>

<PRE>@quit</PRE>

<P>Exits you from the MOO.

<BR></P>

<PRE>@quota</PRE>

<P>Displays your builder's quota, which indicates how many objects you can create.

<BR></P>

<PRE>@recreate <I>old-object</I> as <I>parent-obj</I> named &quot;<I>names</I>&quot;</PRE>

<P>Changes the given old object to a new object with a new parent and a new set of names and aliases. The aliases are a comma-separated list of names, the first of which is taken to be the name of the new object. This command enables you to recycle older, 
unused objects you own into new ones.

<BR></P>

<PRE>@recycle <I>object</I></PRE>

<P>Destroys the given object. You must own the object.

<BR></P>

<PRE>@remove-entrance <I>entrance</I></PRE>

<P>Removes an entrance from the current room.

<BR></P>

<PRE>@remove-exit <I>exit</I></PRE>

<P>Removes an exit from the current room.

<BR></P>

<PRE>@remove-feature <I>feature-object</I></PRE>

<P>Removes a feature from your features list.

<BR></P>

<PRE>@rename <I>object</I> to <I>name</I>,<I>alias</I>,...,<I>alias</I></PRE>

<P>Changes the name of the given object to a new name. The aliases are a comma-separated list of names, the first of which is taken to be the name of the new object.

<BR></P>

<PRE>@rename <I>object</I>:<I>verb</I> to <I>new-verb-name</I></PRE>

<P>Renames a verb on an object to a new name.

<BR></P>

<PRE>@rmalias <I>alias</I> from <I>object</I>

@rmalias <I>alias</I> from <I>object</I>:<I>verb</I></PRE>

<P>Removes an alias from an object or an object verb.

<BR></P>

<PRE>@rmproperty <I>object</I>.<I>property</I></PRE>

<P>Removes a property from an object.

<BR></P>

<PRE>@rmverb <I>object</I>:<I>verb</I></PRE>

<P>Removes a verb from an object.

<BR></P>

<PRE>@sethome</PRE>

<P>Sets your home to the current room.

<BR></P>

<PRE>@show <I>object</I>

@show <I>object</I>:<I>verb</I>

@show <I>object</I>.<I>property</I></PRE>

<P>Displays detailed information about the given object, verb, or property.

<BR></P>

<PRE>@suggest</PRE>

<P>Makes a suggestion to the owner of the current room.

<BR></P>

<PRE>@ungag <I>object</I></PRE>

<P>Removes an object, usually a player, from the list of objects you have gagged.

<BR></P>

<PRE>@unlock <I>object</I></PRE>

<P>Removes the lock on the given object.

<BR></P>

<PRE>@verb <I>object</I>:<I>verb</I></PRE>

<P>Creates a verb on the given object.

<BR></P>

<PRE>@version</PRE>

<P>Displays the version number of the MOO.

<BR></P>

<PRE>@whereis <I>player</I></PRE>

<P>Displays the current location of the specified player.

<BR></P>

<PRE>@who [ <I>player</I> ... <I>player</I> ]</PRE>

<P>Displays the list of people that are currently using the MOO. If one or more specific players are given, information for only those players is displayed. If a specified player is not connected, the last connection time of that player is displayed.

<BR></P>

<PRE>@whois <I>player</I></PRE>

<P>Displays the real-life name and e-mail address of the specified player.

<BR></P>

<PRE>@wrap [ on|off ]</PRE>

<P>Turns line wrapping on or off, as specified.

<BR></P>

<H4><A ID="I158" NAME="I158">

<FONT SIZE=3><B>Message Reference</B>

<BR></FONT></A></H4>

<P>MOOs have a message implementation that is similar to the attribute systems in MUCKs, MUSHes, and MUSEs (such as @drop and @odrop). These at-commands set the messages displayed when certain events happen. In MOO, these messages are a bit more consistent 
than in the older TinyMUD-based muds.

<BR></P>

<P>This section lists the messages that can be set in MOO.

<BR></P>

<P>To set one of these messages, use the following syntax:

<BR></P>

<PRE>@<I>message-name object</I> is &quot;<I>text</I>&quot;</PRE>

<P>For example:

<BR></P>

<PRE>&gt; @drop vase is &quot;You drop the vase. It shatters into a million pieces.&quot;</PRE>

<P>Messages that begin with @o are displayed to other players (besides the enacting player), with the name of the enacting player included in the text of the @o message.

<BR></P>

<P>The messages are listed alphabetically as pairs of messages&#151;the primary message and its corresponding @o message. For each message, if the message has a default, the default message text is given for that particular message. This default message is 
given in parentheses after the message name.

<BR></P>

<H5><A ID="I159" NAME="I159">

<FONT SIZE=3><B>Messages</B>

<BR></FONT></A></H5>

<PRE>@arrive</PRE>

<P>Displayed to the player right after successfully using the exit.

<BR></P>

<P>@oarrive          ( %N has arrived. )

<BR></P>

<P>Displayed to others in the destination room when the player successfully uses the exit.

<BR></P>

<P>@close          ( You close %d. )

<BR></P>

<P>Displayed to the player who closes a container.

<BR></P>

<P>@oclose          ( %N closes %d. )

<BR></P>

<P>Displayed to others in the room when the player closes a container.

<BR></P>

<P>@drop_failed          ( You can't seem to drop %t here. )

<BR></P>

<P>Displayed to the player who fails to drop something.

<BR></P>

<P>@odrop_failed          ( %N tries to drop %t but fails! )

<BR></P>

<P>Displayed to others in the room when the player fails to drop something.

<BR></P>

<P>@drop_succeeded          ( You drop %t. )

<BR></P>

<P>Displayed to the player who drops something.

<BR></P>

<P>@odrop_succeeded          ( %N drops %t. )

<BR></P>

<P>Displayed to others in the room when the player drops something.

<BR></P>

<P>@ejection          ( You expel %d from %i. )

<BR></P>

<P>Displayed to the player who ejects something from the room.

<BR></P>

<P>@oejection          ( %D is unceremoniously expelled from %I by %n. )

<BR></P>

<P>Displayed to others in the room when the player ejects something from the room.

<BR></P>

<P>@empty          ( It is empty. )

<BR></P>

<P>Displayed as the container's contents when the container is empty.

<BR></P>

<PRE>@leave</PRE>

<P>Displayed to the player right before successfully using the exit.

<BR></P>

<P>@oleave          ( %N has left. )

<BR></P>

<P>Displayed to others in the source room when the player successfully uses the exit.

<BR></P>

<P>@nogo          ( You can't go that way. )

<BR></P>

<P>Displayed to the player who fails to use an exit.

<BR></P>

<P>@onogo          (no default)

<BR></P>

<P>Displayed to others in the room when the player fails to use an exit.

<BR></P>

<P>@open          ( You open %d. )

<BR></P>

<P>Displayed to the player who opens a container successfully.

<BR></P>

<P>@oopen          ( opens %d. )

<BR></P>

<P>Displayed to others in the room when the player opens a container successfully.

<BR></P>

<P>@open_fail          ( You can't open that. )

<BR></P>

<P>Displayed to the player who opens a container unsuccessfully.

<BR></P>

<P>@oopen_fail          (no default)

<BR></P>

<P>Displayed to others in the room when the player opens a container unsuccessfully.

<BR></P>

<P>@put          ( You put %d in %i. )

<BR></P>

<P>Displayed to the player who puts something into a container.

<BR></P>

<P>@oput          ( puts %d in %i. )

<BR></P>

<P>Displayed to others in the room when the player puts something into a container.

<BR></P>

<P>@put_fail          ( You can't put %d in that. )

<BR></P>

<P>Displayed to the player who fails to put something into a container.

<BR></P>

<P>@oput_fail

<BR></P>

<P>Displayed to others in the room when the player fails to put something into a container.

<BR></P>

<P>@remove          ( You remove %d from %i. )

<BR></P>

<P>Displayed to the player who removes something from a container.

<BR></P>

<P>@oremove          ( removes %d from %i. )

<BR></P>

<P>Displayed to others in the room when the player removes something from a container.

<BR></P>

<P>@remove_fail          ( You can't remove that. )

<BR></P>

<P>Displayed to the player who fails to remove something from a container.

<BR></P>

<P>@oremove_fail

<BR></P>

<P>Displayed to others in the room when the player fails to remove something from a container.

<BR></P>

<P>@take_failed          ( You can't pick that up. )

<BR></P>

<P>Displayed to the player who fails to take something.

<BR></P>

<P>@otake_failed

<BR></P>

<P>Displayed to others in the room when the player fails to take something.

<BR></P>

<P>@take_succeeded          ( You take %t. )

<BR></P>

<P>Displayed to the player who succeeds in taking something.

<BR></P>

<P>@otake_succeeded          ( picks up %t. )

<BR></P>

<P>Displayed to others in the room when the player succeeds in taking something.

<BR></P>

<P>@victim_ejection          ( You have been expelled from %i by %n. )

<BR></P>

<P>Displayed to the player who is ejected from a room.

<BR></P>

<H4><A ID="I160" NAME="I160">

<FONT SIZE=3><B>Error Reference</B>

<BR></FONT></A></H4>

<TABLE BORDER>

<TR>

<TD>

<PRE><B><I>Error</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Meaning</I></B>

<BR></PRE>

<TR>

<TD>

<P>E_NONE</P>

<TD>

<P>No error</P>

<TR>

<TD>

<P>E_TYPE</P>

<TD>

<P>Type mismatch</P>

<TR>

<TD>

<P>E_DIV</P>

<TD>

<P>Division by zero</P>

<TR>

<TD>

<P>E_PERM</P>

<TD>

<P>Permission denied</P>

<TR>

<TD>

<P>E_PROPNF</P>

<TD>

<P>Property not found</P>

<TR>

<TD>

<P>E_VERBNF</P>

<TD>

<P>Verb not found</P>

<TR>

<TD>

<P>E_VARNF</P>

<TD>

<P>Variable not found</P>

<TR>

<TD>

<P>E_INVIND</P>

<TD>

<P>Invalid indirection</P>

<TR>

<TD>

<P>E_RECMOVE</P>

<TD>

<P>Recursive move</P>

<TR>

<TD>

<P>E_MAXREC</P>

<TD>

<P>Too many verb calls</P>

<TR>

<TD>

<P>E_RANGE</P>

<TD>

<P>Range error</P>

<TR>

<TD>

<P>E_ARGS</P>

<TD>

<P>Incorrect number of arguments</P>

<TR>

<TD>

<P>E_NACC</P>

<TD>

<P>Move refused by destination</P>

<TR>

<TD>

<P>E_INVARG</P>

<TD>

<P>Invalid argument</P>

<TR>

<TD>

<P>E_QUOTA</P>

<TD>

<P>Object ownership quota exceeded</P></TABLE>

<H4><A ID="I161" NAME="I161">

<FONT SIZE=3><B>Built-In Function Reference</B>

<BR></FONT></A></H4>

<P>MOOs come with a set of built-in functions you can access in your MOO programs. These built-in functions are described in this section. For more detailed information, consult the specific topic help documentation on your MOO.

<BR></P>

<P>In addition to these basic built-in functions, many MOOs have packages of utility functions that are also very helpful, such as math utilities, string manipulation, list manipulation, e-mail systems, news systems, democracy and voting systems, and so 
forth. You may want to look at your MOO help for such utilities by typing help utilities or help core-index.

<BR></P>

<P>Throughout this section, the following terminology is used to indicate parameter types and return values.

<BR></P>

<TABLE BORDER>

<TR>

<TD>

<PRE><B><I>Terminology</I></B>

<BR></PRE>

<TD>

<PRE><B><I>Indicates</I></B>

<BR></PRE>

<TR>

<TD>

<P><I>num</I></P>

<TD>

<P>integer</P>

<TR>

<TD>

<P><I>str</I></P>

<TD>

<P>string</P>

<TR>

<TD>

<P><I>obj</I></P>

<TD>

<P>an object</P>

<TR>

<TD>

<P><I>list</I></P>

<TD>

<P>a list of values</P>

<TR>

<TD>

<P><I>void</I></P>

<TD>

<P>no return value</P>

<TR>

<TD>

<P><I>value</I></P>

<TD>

<P>any value</P>

<TR>

<TD>

<P><I>result</I></P>

<TD>

<P>any value</P></TABLE>

<PRE><I>num</I> abs(<I>num</I>)</PRE>

<P>Returns the absolute value of the given number.

<BR></P>

<PRE><I>void</I> add_property(<I>obj</I>, <I>property-name-str</I>, <I>initial-value</I>, <I>info-list</I>)</PRE>

<P>Adds the specified property to the given object and all of its descendants The property will have the given initial value, and its property information will be set to the given property information list. If any of the arguments are invalid, the error 
E_INVARG is returned. If the programmer does not have write permission on the object, E_PERM is returned. If the object does not have a property with the specified name, E_PROPNF is returned.

<BR></P>

<PRE><I>void</I> add_verb(<I>obj</I>, <I>info-list</I>, <I>args-list</I>)</PRE>

<P>Creates a new verb on the given object. The new verb's owner, permissions, and name (or names) is specified by the information list. The new verb's direct object, preposition, and indirect object are specified in the argument list. If any of the 
arguments is invalid, the error E_INVARG is returned. If the programmer does not have write permission on the object, E_PERM is returned.

<BR></P>

<PRE><I>list </I>callers()</PRE>

<P>Returns a list of the verbs that have called the current task. Similar to a trace of the verbs that have successively called other verbs, resulting in the current task being executed.

<BR></P>

<PRE><I>obj</I> caller_perms()</PRE>

<P>Returns the currently-executing verb's caller's permissions.

<BR></P>

<PRE>void clear_property(obj, property-name-str)</PRE>

<P>Clears the specified property on the given object. Clear properties return the value of the parent's property when accessed, as opposed to their own value. If the programmer does not have write permission on the object, the error E_PERM is returned. If 
the object is not valid, E_INVARG is returned. If the given object defines the specified property, as opposed to inheriting it, E_INVARG is returned. If the object does not have a property with the specified name, E_PROPNF is returned.

<BR></P>

<PRE><I>list</I> children(<I>obj</I>)</PRE>

<P>Returns a list of the children of the given object.

<BR></P>

<PRE><I>void</I> chparent(<I>obj</I>, <I>new-parent-obj</I>)</PRE>

<P>Changes the parent of the given object to the given new parent object. If the given object is not valid, E_INVARG is returned. If the new parent object is not fertile (has its &quot;f&quot; bit set) or is not owned by the owner of the given object, 
E_PERM is returned.

<BR></P>

<PRE><I>str</I> connection_name(<I>obj</I>)</PRE>

<P>Returns the name of the connection being used by the player.

<BR></P>

<PRE><I>list</I> connected_players()</PRE>

<P>Returns a list of the object numbers of the players currently connected to the MOO.

<BR></P>

<PRE><I>num</I> connected_seconds(<I>player-obj</I>)</PRE>

<P>Returns the number of seconds the given player object has been connected to the MOO.

<BR></P>

<PRE><I>obj</I> create(<I>parent-obj</I> [, <I>owner-obj</I>)</PRE>

<P>Creates a new object that has the given parent object as its parent. If the owner object is not specified, the owner is the programmer. If the owner object is #-1, the object is its own owner. If the owner object is a valid object, it becomes the owner 
of the newly created object. The new object's name is the empty string, its location is initialized to nothing (#-1), and it has no contents. The various property flags are set to zero. In addition, the new object inherits other properties from its parent 
object. The parent must be fertile (have its &quot;f&quot; bit set) or must be owned by the programmer. Otherwise, the error E_PERM is returned. If the player creating the object cannot do so because of a quota limitation, the error E_QUOTA is returned.

<BR></P>

<PRE><I>str</I> crypt(<I>str</I>)</PRE>

<P>Encrypts the given string and returns the encrypted string.

<BR></P>

<PRE><I>str</I> ctime([<I>time-num</I>])</PRE>

<P>Uses the given time number to create a string that specifies the time. If the time number is not given, the current time is used. The format of the string is <I>DDD</I> <I>MMM</I> <I>XX</I> <I>HH</I>:<I>MM</I>:<I>SS</I> <I>YYYY</I> <I>TZN</I>, as in Tue 
Jul 19 12:00:00 1994 EST.

<BR></P>

<PRE><I>void</I> delete_property(<I>obj</I>, <I>property-name-str</I>)</PRE>

<P>Deletes the specified property from the given object and all of its descendants. If the programmer does not have write permission on the object, the error E_PERM is returned. If any of the arguments are not valid, E_INVARG is returned. If the object 
does not have a property with the specified name, E_PROPNF is returned.

<BR></P>

<PRE><I>void</I> delete_verb(<I>obj</I>, <I>verb-name-str</I>)</PRE>

<P>Deletes the specified verb from the object and all of its descendants. If any of the arguments are invalid, the error E_INVARG is returned. If the programmer does not have write permission on the object, E_PERM is returned.

<BR></P>

<PRE><I>list</I> eval(<I>str</I>)</PRE>

<P>Evaluates the given string as though it were a piece of MOO code. The returned value is a list. The first item in the list is either 1, indicating that the code did not have compilation errors, or 0, indicating that it did. The second item in the list 
is either the result of the evaluation if there were no compilation errors, or a string denoting the compiler error messages if there were such errors.

<BR></P>

<PRE><I>num</I> idle_seconds(<I>player-obj</I>)</PRE>

<P>Returns the number of seconds the given player object has been idle on the MOO.

<BR></P>

<PRE><I>num</I> index(<I>subj-str</I>, <I>pattern-str</I> [, CASE-MATTERS})</PRE>

<P>Finds the first occurrence of the pattern string in the given subject string, and returns the index of this first occurrence of such pattern in the subject. Case is significant only if the optional CASE-MATTERS specifier is given.

<BR></P>

<PRE><I>num</I> is_clear_property(<I>obj</I>, <I>property-name-str</I>)</PRE>

<P>Returns 1 if the property on the object is clear, 0 otherwise. Clear properties return the value of the parent's property when accessed, as opposed to their own value. If the programmer does not have read permission on the object, the error E_PERM is 
returned. If the object is not valid, E_INVARG is returned. If the object does not have a property with the specified name, E_PROPNF is returned.

<BR></P>

<PRE><I>num</I> is_player(<I>obj</I>)</PRE>

<P>Returns a non-zero value if the given object is a player, otherwise returns 0. If the given object is not valid, E_INVARG is returned.

<BR></P>

<PRE><I>void</I> kill_tasks(<I>task-id-num</I>)</PRE>

<P>Stops the given task by removing it from the list of queued tasks.

<BR></P>

<PRE><I>num</I> length(<I>list</I>)</PRE>

<P>Returns the number of items in the given list.

<BR></P>

<PRE><I>num</I> length(<I>str</I>)</PRE>

<P>Returns the length of the given string.

<BR></P>

<PRE><I>list</I> listappend(<I>list</I>, <I>value</I>, [, <I>index-num</I>])</PRE>

<P>Inserts the given value into the given list at the end of the list. If the optional index number is specified, the value is inserted after the value in the list with that index. Lists are always indexed beginning at 1.

<BR></P>

<PRE><I>list</I> listdelete(<I>list</I>, <I>index-num</I>)</PRE>

<P>Deletes the index-th item from the list, and returns the new list. If the given index is out of range of the list, the error E_RANGE is returned.

<BR></P>

<PRE><I>list</I> listinsert(<I>list</I>, <I>value</I>, [, <I>index-num</I>])</PRE>

<P>Inserts the given value into the given list at the beginning of the list. If the optional index number is specified, the value is inserted before the value in the list with that index. Lists are always indexed beginning at 1.

<BR></P>

<PRE><I>list</I> listset(<I>list</I>, <I>value</I>, <I>index-num</I>)</PRE>

<P>Sets the index-th item in the given list to the given value.

<BR></P>

<PRE><I>list</I> match(<I>subj-str</I>, <I>pattern-str</I> [, CASE-MATTERS])</PRE>

<P>Searches for the first occurrence of the pattern in the subject. If found, a list of information pertaining to the match is returned. The pattern can contain special MOO regular expressions. For more details, consult the MOO help.

<BR></P>

<PRE><I>num</I> max(<I>num1</I>, <I>num2</I>, ..., <I>numN</I>)</PRE>

<P>Returns the maximum of the given set of numbers. If any argument is not a number, E_TYPE is returned.

<BR></P>

<PRE><I>obj</I> max_object()</PRE>

<P>Returns the highest object number of the currently existing objects.

<BR></P>

<PRE><I>num</I> min(<I>num1</I>, <I>num2</I>, ..., <I>numN</I>)</PRE>

<P>Returns the minimum of the given set of numbers. If any argument is not a number, E_TYPE is returned.

<BR></P>

<PRE><I>void</I> move(<I>obj</I>, <I>location-obj</I>)</PRE>

<P>Moves the given object to the given location. Various permissions are checked to make sure that the object has permission to move to the specified location.

<BR></P>

<PRE><I>void</I> notify(<I>player-obj</I>, <I>str</I>)</PRE>

<P>Displays the given string to the given player.

<BR></P>

<PRE><I>obj</I> parent(<I>obj</I>)</PRE>

<P>Returns the parent object of the given object.

<BR></P>

<PRE><I>result</I> pass(<I>args</I>, ....)</PRE>

<P>Calls the verb defined on the parent object with the same name as the current verb. This enables programmers to define verbs that add onto the actions of parent object verbs.

<BR></P>

<PRE><I>list</I> players()</PRE>

<P>Returns a list of the object numbers of all the players that are in the database.

<BR></P>

<PRE><I>list</I> properties(<I>obj</I>)</PRE>

<P>Returns a list of the names of the properties defined on the given object. If the object is not valid, the error E_INVARG is returned. If the programmer does not have permission to read the properties, E_PERM is returned.

<BR></P>

<PRE><I>list</I> property_info(<I>obj</I>, <I>property-name-str</I>)</PRE>

<P>Returns a list containing information about the specified property on the given object. The list that is returned has the form { owner, permissions }. The owner is the owner of the property, and permissions is a string denoting if the property is 
readable, writable, or child-owner-inheritable (r, w, and c, respectively). If the programmer does not have read permission on the object, the error E_PERM is returned. If the object is not valid, E_INVARG is returned. If the object does not have a 
property with the specified name, E_PROPNF is returned.

<BR></P>

<PRE><I>list</I> queued_tasks()</PRE>

<P>Returns a list denoting the tasks owned by the programmer, whether they are forked, suspended, or reading user input.

<BR></P>

<PRE><I>num</I> random(<I>num</I>)</PRE>

<P>Returns a random number from 1 to the given number. If the argument is a negative number, the error E_INVARG is returned.

<BR></P>

<PRE><I>str</I> read([<I>player-obj</I>])</PRE>

<P>Suspends the current task, waits for the user to enter a line of text, then resumes execution by returning the text line as a string. Fails if the task has already been suspended.

<BR></P>

<PRE><I>void</I> recycle(<I>obj</I>)</PRE>

<P>Recycles the given object. The object is permanently destroyed. If the programmer does not own the object, the error E_PERM is returned. If the object is not valid, E_INVARG is returned. The given object's parent becomes the parent of the given object's 
children.

<BR></P>

<PRE><I>num</I> rindex(<I>subj-str</I>, <I>pattern-str</I> [, CASE-MATTERS])</PRE>

<P>Finds the last occurrence of the pattern string in the given subject string, and returns the index in the subject that matches the first character of the pattern. Case is significant only if the optional CASE-MATTERS specifier is given.

<BR></P>

<PRE><I>list</I> rmatch(<I>subj-str</I>, <I>pattern-str</I> [, CASE-MATTERS])</PRE>

<P>Searches for the last occurrence of the pattern in the subject. If found, a list of information pertaining to the match is returned. The pattern can contain special MOO regular expressions. For more detail, consult the MOO help.

<BR></P>

<PRE><I>num</I> seconds_left()</PRE>

<P>Returns the number of seconds left before the currently-executing task will be terminated due to time constraints.

<BR></P>

<PRE><I>str</I> server_version()</PRE>

<P>Returns a string denoting the version of the MOO server.

<BR></P>

<PRE><I>list</I> setadd(<I>list</I>, <I>value</I>)</PRE>

<P>Adds the given value to the given list. The list is considered to be a set of values&#151;thus, the value is not added to the list if it already exists in the list.

<BR></P>

<PRE><I>list</I> setremove(<I>list</I>, <I>value</I>)</PRE>

<P>Removes the given value to the given list. If the value occurs more than once in the list, only the first occurrence of the value is removed from the list.

<BR></P>

<PRE><I>void</I> set_player_flag(<I>obj</I>, <I>value</I>)</PRE>

<P>Sets the player status of the given object to the specified value. If the value is non-zero, the object is a player. If the value is 0, the object ceases to be a player. If the object is not a valid object, E_INVARG is returned.

<BR></P>

<PRE><I>void</I> set_property_info(<I>obj</I>, <I>property-name-str</I>, <I>info-list</I>)</PRE>

<P>Sets the specified property on the given object to the specified property information list. This list has the format { <I>owner</I>, <I>permissions</I> }, where the owner is the owner of the property and permissions is a string denoting if the property 
is readable, writable and child-owner-inheritable (r, w, and c, respectively). If the programmer does not have write permission on the object, the error E_PERM is returned. If the object is not valid, E_INVARG is returned. If the object does not have a 
property with the specified name, E_PROPNF is returned.

<BR></P>

<PRE><I>void</I> set_task_perms(<I>obj</I>)</PRE>

<P>Changes the currently-executing verb's permissions to be the same as the given object's.

<BR></P>

<PRE><I>void</I> set_verb_args(<I>obj</I>, <I>verb-name-str</I>, <I>info-list</I>)</PRE>

<P>Sets the argument list of the specified verb on the given object. This list has the form {<I>direct-obj</I>, <I>preposition</I>, <I>indirect-obj</I>}. If the object is not valid, the error E_INVARG is returned. If the programmer does not have write 
permission on the object, E_PERM is returned. If the specified verb name does not exist on the given object, E_VERBNF is returned.

<BR></P>

<PRE><I>void</I> set_verb_code(<I>obj</I>, <I>verb-name-str</I>, <I>code-list</I>)</PRE>

<P>Sets the code listing associated with the specified verb on the given object. If the object is not valid, the error E_INVARG is returned. If the programmer does not have read permission on the object, E_PERM is returned. If the specified verb name does 
not exist on the given object, E_VERBNF is returned.

<BR></P>

<PRE><I>void</I> set_verb_info(<I>obj</I>, <I>verb-name-str</I>, <I>info-list</I>)</PRE>

<P>Sets the information list associated with the specified verb on the given object. The list has the form { <I>owner</I>, <I>permissions</I>, <I>names</I> }, where owner is the owner of the object, permissions denote whether the verb is readable, 
writable, executable, or in debug mode (r, w, x, and d, respectively), and names denote synonymous names of the verb. If the object is not valid, the error E_INVARG is returned. If the programmer does not have write permission on the object, E_PERM is 
returned. If the specified verb name does not exist on the given object, E_VERBNF is returned.

<BR></P>

<PRE><I>num</I> sqrt(<I>num</I>)</PRE>

<P>Returns the square root of the given number. If the given number is negative, the error E_INVARG is returned.

<BR></P>

<PRE><I>num</I> strcmp(<I>str1</I>, <I>str2</I>)</PRE>

<P>Compares the two strings. If <I>str1</I> is lexicographically less than <I>str2</I>, a negative number is returned. If <I>str1</I> is lexicographically greater than <I>str2</I>, a positive number is returned. If the two strings are equal, 0 is returned.


<BR></P>

<PRE><I>str</I> strsub(<I>subj-str</I>, <I>pattern-str</I>, <I>replacement-str</I> [, CASE-MATTERS])</PRE>

<P>Replaces the given pattern string in the given subject string with the given replacement string. If the optional CASE-MATTERS specifier is given, case is significant when the pattern matches substrings in the subject.

<BR></P>

<PRE><I>void</I> suspend(<I>seconds-num</I>)</PRE>

<P>Suspends the currently-executing task for at least the specified number of seconds. Afterwards, the task resumes execution.

<BR></P>

<PRE><I>num</I> task_id()</PRE>

<P>Returns the task identifier for the currently executing task.

<BR></P>

<PRE><I>num</I> ticks_left()</PRE>

<P>Returns the number of seconds left before the currently-executing task will be terminated due to time constraints.

<BR></P>

<PRE><I>num</I> time()</PRE>

<P>Returns the number of seconds elapsed since January 1, 1970.

<BR></P>

<PRE><I>obj</I> toobj(<I>value</I>)</PRE>

<P>Converts the given value to an object number. Numbers are converted to object numbers. Strings that represent numbers are converted to object numbers, also. Such strings can begin with a # symbol. Lists return the E_TYPE error.

<BR></P>

<PRE><I>num</I> tonum(<I>value</I>)</PRE>

<P>Converts the given value to a number. Objects are converted to their object numbers. Strings are converted to their numeric values. If the value is a string, but does not represent a number, 0 is returned. If the value is a list, the error E_TYPE is 
returned.

<BR></P>

<PRE><I>str</I> tostr(<I>value</I>)</PRE>

<P>Converts the given value to a string. If the given value is a list, the string {list} is returned.

<BR></P>

<PRE><I>num</I> typeof(<I>value</I>)</PRE>

<P>Returns the type of the given value. This number will be one of the following constants: NUM, STR, LIST, OBJ, or ERR.

<BR></P>

<PRE><I>num</I> valid(<I>obj</I>)</PRE>

<P>Returns a non-zero number if the given object is a valid object and 0 if the given object is not a valid object. A valid object is one that has been created and not recycled.

<BR></P>

<PRE><I>list</I> verbs(<I>obj</I>)</PRE>

<P>Returns a list of the names of the verbs defined on the given object. If the object is not a valid object, E_INVARG is returned. If the programmer does not have permission to read the object, E_PERM is returned.

<BR></P>

<PRE><I>list</I> verb_args(<I>obj</I>, <I>verb-name-str</I>)</PRE>

<P>Returns the argument list of the specified verb on the given object. This list has the form {<I>direct-obj</I>, <I>preposition</I>, <I>indirect-obj</I>}. If the object is not valid, the error E_INVARG is returned. If the programmer does not have read 
permission on the object, E_PERM is returned. If the specified verb name does not exist on the given object, E_VERBNF is returned.

<BR></P>

<PRE><I>list</I> verb_code(<I>obj</I>, <I>verb-name-str</I>)</PRE>

<P>Returns a listing of the code associated with the specified verb on the given object. If the object is not valid, the error E_INVARG is returned. If the programmer does not have read permission on the object, E_PERM is returned. If the specified verb 
name does not exist on the given object, E_VERBNF is returned.

<BR></P>

<PRE><I>list</I> verb_info(<I>obj</I>, <I>verb-name-str</I>)</PRE>

<P>Returns a list of the information associated with the specified verb on the given object. The list has the form { <I>owner</I>, <I>permissions</I>, <I>names</I> }, where owner is the owner of the object, permissions denotes whether the verb is readable, 
writable, executable, or in debug mode (r, w, x, and d, respectively), and names denote synonymous names of the verb. If the object is not valid, the error E_INVARG is returned. If the programmer does not have read permission on the object, E_PERM is 
returned. If the specified verb name does not exist on the given object, E_VERBNF is returned.

<BR></P>

<H3><A ID="I162" NAME="I162">

<FONT SIZE=4><B>Summary</B>

<BR></FONT></A></H3>

<P>You are now completely prepared to create environments of astounding complexity and lifelike responsiveness. All the tools in the world, however, won't help you if you wander around from area to area without completing anything coherent. The creation of 
coherent, consistent, and entertaining interactive environments is a nascent artform, one that requires not only programming capability but artistic sensibility as well.

<BR></P>

<P>What is a mud? In a strict sense, it is a highly structured imaginative exercise&#151;that is, a game&#151;which involves the simulation of a fictional reality on a literary and dramatic level. The goal of interactive narrative is to allow the 
participants to project their various alter-egos into your world-specific simulations, discovering problems and resolutions with a high degree of internal consistency.

<BR></P>

<P>A fledgling devotion somewhere between art and science, interactive narrative design relies upon a tricky sort of relativistic thinking&#151;the attainment of an object-and-pattern-oriented skill set, which in itself is a new and exciting development. 
This mental skill set draws its inspirations from the fields of game theory and computer programming, as well as the more traditional narrative arts. But unlike the traditional novelist or playwright, whose stories progress in a linear fashion from event 
to event, a mud builder cannot simply decide which interesting turn the plotline &quot;should&quot; take next. Here in the living electronic world, players are free to move through your story in any variety of ways, and you should be ready to give that 
freedom to them. Consider all your possible &quot;branch-points&quot; and combinations of story elements, and draw a practical but flexible conceptual framework to encompass their interplay.

<BR></P>

<P>With a little brainstorming and a few handy commands, it's possible to flesh your design out in short time; creating intricate mazes of interacting elements. Try to alternately tighten and release your control over the plotline as the players proceed; 
rely instead on your descriptive and programming skills; you don't want players to feel restricted within the conceptual confines of your narrative. By concentrating on the quality and detail of your interactive elements, you will shift the players' 
attention&#151;and more importantly, your own&#151;from the <I>structural mechanics </I>of interactive stories to the stories themselves.

<BR></P>

<P>After spending a bit of time as a mud programmer, you should really be getting the hang of it. You should be able to settle into a groove that feels natural and economic for you, using these pages as your handbook. Soon after that, you'll be interacting 
<I>with </I>the text, <I>on </I>it, and <I>in </I>it!

<BR></P>

<P><A HREF="tigp3.htm"><IMG SRC="bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Previous Page"></A>

<A HREF="httoc.htm"><IMG SRC="blutoc.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="TOC"></A>

<A HREF="htindex.htm"><IMG SRC="bluindex.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Index"></A>

<A HREF="tig12.htm"><IMG SRC="blunext.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Next Page"></A>

<A HREF="httoc.htm"><IMG SRC="bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Home"></A>

</P></BODY></HTML>

